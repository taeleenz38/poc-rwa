{
  "language": "Solidity",
  "sources": {
    "contracts/external/chainalysis/ISanctionsList.sol": {
      "content": "/// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\ninterface ISanctionsList {\r\n  function isSanctioned(address addr) external view returns (bool);\r\n}\r\n"
    },
    "contracts/sanctions/SanctionsListClientUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\r\nimport \"contracts/sanctions/ISanctionsListClient.sol\";\r\n\r\n/**\r\n * @title SanctionsListClient\r\n * @author Ondo Finance\r\n * @notice This abstract contract enables inheritors to query whether accounts\r\n *         are sanctioned or not\r\n */\r\nabstract contract SanctionsListClientUpgradeable is\r\n  Initializable,\r\n  ISanctionsListClient\r\n{\r\n  // Sanctions list address\r\n  ISanctionsList public override sanctionsList;\r\n\r\n  /**\r\n   * @notice Initialize the contract by setting blocklist variable\r\n   *\r\n   * @param _sanctionsList Address of the sanctionsList contract\r\n   *\r\n   * @dev Function should be called by the inheriting contract on\r\n   *      initialization\r\n   */\r\n  function __SanctionsListClientInitializable_init(\r\n    address _sanctionsList\r\n  ) internal onlyInitializing {\r\n    __SanctionsListClientInitializable_init_unchained(_sanctionsList);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to future-proof parent linearization. Matches OZ\r\n   *      upgradeable suggestions\r\n   */\r\n  function __SanctionsListClientInitializable_init_unchained(\r\n    address _sanctionsList\r\n  ) internal onlyInitializing {\r\n    _setSanctionsList(_sanctionsList);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the sanctions list address for this client\r\n   *\r\n   * @param _sanctionsList The new sanctions list address\r\n   */\r\n  function _setSanctionsList(address _sanctionsList) internal {\r\n    if (_sanctionsList == address(0)) {\r\n      revert SanctionsListZeroAddress();\r\n    }\r\n    address oldSanctionsList = address(sanctionsList);\r\n    sanctionsList = ISanctionsList(_sanctionsList);\r\n    emit SanctionsListSet(oldSanctionsList, _sanctionsList);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether an address has been sanctioned\r\n   *\r\n   * @param account The account to check\r\n   */\r\n  function _isSanctioned(address account) internal view returns (bool) {\r\n    return sanctionsList.isSanctioned(account);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   * @custom:oz-retyped-from bool\r\n   */\r\n  uint8 private _initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private _initializing;\r\n\r\n  /**\r\n   * @dev Triggered when the contract has been initialized or reinitialized.\r\n   */\r\n  event Initialized(uint8 version);\r\n\r\n  /**\r\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\r\n   */\r\n  modifier initializer() {\r\n    bool isTopLevelCall = !_initializing;\r\n    require(\r\n      (isTopLevelCall && _initialized < 1) ||\r\n        (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n      \"Initializable: contract is already initialized\"\r\n    );\r\n    _initialized = 1;\r\n    if (isTopLevelCall) {\r\n      _initializing = true;\r\n    }\r\n    _;\r\n    if (isTopLevelCall) {\r\n      _initializing = false;\r\n      emit Initialized(1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n   * used to initialize parent contracts.\r\n   *\r\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\r\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\r\n   * initialization.\r\n   *\r\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n   * a contract, executing them in the right order is up to the developer or operator.\r\n   */\r\n  modifier reinitializer(uint8 version) {\r\n    require(\r\n      !_initializing && _initialized < version,\r\n      \"Initializable: contract is already initialized\"\r\n    );\r\n    _initialized = version;\r\n    _initializing = true;\r\n    _;\r\n    _initializing = false;\r\n    emit Initialized(version);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n   */\r\n  modifier onlyInitializing() {\r\n    require(_initializing, \"Initializable: contract is not initializing\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n   * through proxies.\r\n   */\r\n  function _disableInitializers() internal virtual {\r\n    require(!_initializing, \"Initializable: contract is initializing\");\r\n    if (_initialized < type(uint8).max) {\r\n      _initialized = type(uint8).max;\r\n      emit Initialized(type(uint8).max);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/sanctions/ISanctionsListClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\r\n\r\n/**\r\n * @title ISanctionsListClient\r\n * @author Ondo Finance\r\n * @notice The client interface for sanctions contract.\r\n */\r\ninterface ISanctionsListClient {\r\n  /// @notice Returns reference to the sanctions list that this client queries\r\n  function sanctionsList() external view returns (ISanctionsList);\r\n\r\n  /// @notice Sets the sanctions list reference\r\n  function setSanctionsList(address sanctionsList) external;\r\n\r\n  /// @notice Error for when caller attempts to set the `sanctionsList`\r\n  ///         reference to the zero address\r\n  error SanctionsListZeroAddress();\r\n\r\n  /// @notice Error for when caller attempts to perform an action on a\r\n  ///         sanctioned account\r\n  error SanctionedAccount();\r\n\r\n  /**\r\n   * @dev Event for when the sanctions list reference is set\r\n   *\r\n   * @param oldSanctionsList The old list\r\n   * @param newSanctionsList The new list\r\n   */\r\n  event SanctionsListSet(address oldSanctionsList, address newSanctionsList);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n   *\r\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n   * constructor.\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize/address.code.length, which returns 0\r\n    // for contracts in construction, since the code is only stored at the end\r\n    // of the constructor execution.\r\n\r\n    return account.code.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n    (bool success, ) = recipient.call{value: amount}(\"\");\r\n    require(\r\n      success,\r\n      \"Address: unable to send value, recipient may have reverted\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain `call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   *\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   *\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `target` must be a contract.\r\n   * - calling `target` with `data` must not revert.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return functionCall(target, data, \"Address: low-level call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n   * `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but also transferring `value` wei to `target`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the calling contract must have an ETH balance of at least `value`.\r\n   * - the called Solidity function must be `payable`.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        \"Address: low-level call with value failed\"\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      \"Address: insufficient balance for call\"\r\n    );\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n   * revert reason using the provided one.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/usdy/USDY.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PresetMinterPauserUpgradeable.sol\";\r\nimport \"contracts/usdy/blocklist/BlocklistClientUpgradeable.sol\";\r\nimport \"contracts/usdy/allowlist/AllowlistClientUpgradeable.sol\";\r\nimport \"contracts/sanctions/SanctionsListClientUpgradeable.sol\";\r\n\r\ncontract USDY is\r\n  ERC20PresetMinterPauserUpgradeable,\r\n  BlocklistClientUpgradeable,\r\n  AllowlistClientUpgradeable,\r\n  SanctionsListClientUpgradeable\r\n{\r\n  bytes32 public constant LIST_CONFIGURER_ROLE =\r\n    keccak256(\"LIST_CONFIGURER_ROLE\");\r\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\r\n\r\n  /// @custom:oz-upgrades-unsafe-allow constructor\r\n  constructor() {\r\n    _disableInitializers();\r\n  }\r\n\r\n  function initialize(\r\n    string memory name,\r\n    string memory symbol,\r\n    address blocklist,\r\n    address allowlist,\r\n    address sanctionsList\r\n  ) public initializer {\r\n    __ERC20PresetMinterPauser_init(name, symbol);\r\n    __BlocklistClientInitializable_init(blocklist);\r\n    __AllowlistClientInitializable_init(allowlist);\r\n    __SanctionsListClientInitializable_init(sanctionsList);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the blocklist address\r\n   *\r\n   * @param blocklist New blocklist address\r\n   */\r\n  function setBlocklist(\r\n    address blocklist\r\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\r\n    _setBlocklist(blocklist);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the allowlist address\r\n   *\r\n   * @param allowlist New allowlist address\r\n   */\r\n  function setAllowlist(\r\n    address allowlist\r\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\r\n    _setAllowlist(allowlist);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the sanctions list address\r\n   *\r\n   * @param sanctionsList New sanctions list address\r\n   */\r\n  function setSanctionsList(\r\n    address sanctionsList\r\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\r\n    _setSanctionsList(sanctionsList);\r\n  }\r\n\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal override {\r\n    super._beforeTokenTransfer(from, to, amount);\r\n\r\n    // Check constraints when `transferFrom` is called to facliitate\r\n    // a transfer between two parties that are not `from` or `to`.\r\n    if (from != msg.sender && to != msg.sender) {\r\n      require(!_isBlocked(msg.sender), \"USDY: 'sender' address blocked\");\r\n      require(!_isSanctioned(msg.sender), \"USDY: 'sender' address sanctioned\");\r\n      require(\r\n        _isAllowed(msg.sender),\r\n        \"USDY: 'sender' address not on allowlist\"\r\n      );\r\n    }\r\n\r\n    if (from != address(0)) {\r\n      // If not minting\r\n      require(!_isBlocked(from), \"USDY: 'from' address blocked\");\r\n      require(!_isSanctioned(from), \"USDY: 'from' address sanctioned\");\r\n      require(_isAllowed(from), \"USDY: 'from' address not on allowlist\");\r\n    }\r\n\r\n    if (to != address(0)) {\r\n      // If not burning\r\n      require(!_isBlocked(to), \"USDY: 'to' address blocked\");\r\n      require(!_isSanctioned(to), \"USDY: 'to' address sanctioned\");\r\n      require(_isAllowed(to), \"USDY: 'to' address not on allowlist\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Burns a specific amount of tokens\r\n   *\r\n   * @param from The account whose tokens will be burned\r\n   * @param amount The amount of token to be burned\r\n   *\r\n   * @dev This function can be considered an admin-burn and is only callable\r\n   *      by an address with the `BURNER_ROLE`\r\n   */\r\n  function burn(address from, uint256 amount) external onlyRole(BURNER_ROLE) {\r\n    _burn(from, amount);\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PresetMinterPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev {ERC20} token, including:\r\n *\r\n *  - ability for holders to burn (destroy) their tokens\r\n *  - a minter role that allows for token minting (creation)\r\n *  - a pauser role that allows to stop all token transfers\r\n *\r\n * This contract uses {AccessControl} to lock permissioned functions using the\r\n * different roles - head to its documentation for details.\r\n *\r\n * The account that deploys the contract will be granted the minter and pauser\r\n * roles, as well as the default admin role, which will let it grant both minter\r\n * and pauser roles to other accounts.\r\n *\r\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\r\n */\r\ncontract ERC20PresetMinterPauserUpgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  AccessControlEnumerableUpgradeable,\r\n  ERC20BurnableUpgradeable,\r\n  ERC20PausableUpgradeable\r\n{\r\n  function initialize(string memory name, string memory symbol)\r\n    public\r\n    virtual\r\n    initializer\r\n  {\r\n    __ERC20PresetMinterPauser_init(name, symbol);\r\n  }\r\n\r\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n\r\n  /**\r\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\r\n   * account that deploys the contract.\r\n   *\r\n   * See {ERC20-constructor}.\r\n   */\r\n  function __ERC20PresetMinterPauser_init(\r\n    string memory name,\r\n    string memory symbol\r\n  ) internal onlyInitializing {\r\n    __ERC20_init_unchained(name, symbol);\r\n    __Pausable_init_unchained();\r\n    __ERC20PresetMinterPauser_init_unchained(name, symbol);\r\n  }\r\n\r\n  function __ERC20PresetMinterPauser_init_unchained(\r\n    string memory,\r\n    string memory\r\n  ) internal onlyInitializing {\r\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n\r\n    _setupRole(MINTER_ROLE, _msgSender());\r\n    _setupRole(PAUSER_ROLE, _msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Creates `amount` new tokens for `to`.\r\n   *\r\n   * See {ERC20-_mint}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `MINTER_ROLE`.\r\n   */\r\n  function mint(address to, uint256 amount) public virtual {\r\n    require(\r\n      hasRole(MINTER_ROLE, _msgSender()),\r\n      \"ERC20PresetMinterPauser: must have minter role to mint\"\r\n    );\r\n    _mint(to, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Pauses all token transfers.\r\n   *\r\n   * See {ERC20Pausable} and {Pausable-_pause}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `PAUSER_ROLE`.\r\n   */\r\n  function pause() public virtual {\r\n    require(\r\n      hasRole(PAUSER_ROLE, _msgSender()),\r\n      \"ERC20PresetMinterPauser: must have pauser role to pause\"\r\n    );\r\n    _pause();\r\n  }\r\n\r\n  /**\r\n   * @dev Unpauses all token transfers.\r\n   *\r\n   * See {ERC20Pausable} and {Pausable-_unpause}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `PAUSER_ROLE`.\r\n   */\r\n  function unpause() public virtual {\r\n    require(\r\n      hasRole(PAUSER_ROLE, _msgSender()),\r\n      \"ERC20PresetMinterPauser: must have pauser role to unpause\"\r\n    );\r\n    _unpause();\r\n  }\r\n\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\r\n    super._beforeTokenTransfer(from, to, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/usdy/blocklist/BlocklistClientUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IBlocklist.sol\";\r\nimport \"contracts/interfaces/IBlocklistClient.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @title BlocklistClient\r\n * @author Ondo Finance\r\n * @notice This abstract contract manages state for upgradeable blocklist\r\n *         clients\r\n */\r\nabstract contract BlocklistClientUpgradeable is\r\n  Initializable,\r\n  IBlocklistClient\r\n{\r\n  // Blocklist contract\r\n  IBlocklist public override blocklist;\r\n\r\n  /**\r\n   * @notice Initialize the contract by setting blocklist variable\r\n   *\r\n   * @param _blocklist Address of the blocklist contract\r\n   *\r\n   * @dev Function should be called by the inheriting contract on\r\n   *      initialization\r\n   */\r\n  function __BlocklistClientInitializable_init(\r\n    address _blocklist\r\n  ) internal onlyInitializing {\r\n    __BlocklistClientInitializable_init_unchained(_blocklist);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to future-proof parent linearization. Matches OZ\r\n   *      upgradeable suggestions\r\n   */\r\n  function __BlocklistClientInitializable_init_unchained(\r\n    address _blocklist\r\n  ) internal onlyInitializing {\r\n    _setBlocklist(_blocklist);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the blocklist address for this client\r\n   *\r\n   * @param _blocklist The new blocklist address\r\n   */\r\n  function _setBlocklist(address _blocklist) internal {\r\n    if (_blocklist == address(0)) {\r\n      revert BlocklistZeroAddress();\r\n    }\r\n    address oldBlocklist = address(blocklist);\r\n    blocklist = IBlocklist(_blocklist);\r\n    emit BlocklistSet(oldBlocklist, _blocklist);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether an address has been blocked\r\n   *\r\n   * @param account The account to check\r\n   */\r\n  function _isBlocked(address account) internal view returns (bool) {\r\n    return blocklist.isBlocked(account);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/usdy/allowlist/AllowlistClientUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IAllowlist.sol\";\r\nimport \"contracts/interfaces/IAllowlistClient.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @title AllowlistClientInitializable\r\n * @author Ondo Finance\r\n * @notice This abstract contract manages state required for clients\r\n *         of the allowlist\r\n */\r\nabstract contract AllowlistClientUpgradeable is\r\n  Initializable,\r\n  IAllowlistClient\r\n{\r\n  // allowlist address\r\n  IAllowlist public override allowlist;\r\n\r\n  /**\r\n   * @notice Initialize the contract by setting allowlist variable\r\n   *\r\n   * @param _allowlist Address of the allowlist contract\r\n   *\r\n   * @dev Function should be called by the inheriting contract on\r\n   *      initialization\r\n   */\r\n  function __AllowlistClientInitializable_init(\r\n    address _allowlist\r\n  ) internal onlyInitializing {\r\n    __AllowlistClientInitializable_init_unchained(_allowlist);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to future-proof parent linearization. Matches OZ\r\n   *      upgradeable suggestions\r\n   */\r\n  function __AllowlistClientInitializable_init_unchained(\r\n    address _allowlist\r\n  ) internal onlyInitializing {\r\n    _setAllowlist(_allowlist);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the allowlist address for this client\r\n   *\r\n   * @param _allowlist The new allowlist address\r\n   */\r\n  function _setAllowlist(address _allowlist) internal {\r\n    if (_allowlist == address(0)) {\r\n      revert AllowlistZeroAddress();\r\n    }\r\n    address oldAllowlist = address(allowlist);\r\n    allowlist = IAllowlist(_allowlist);\r\n    emit AllowlistSet(oldAllowlist, _allowlist);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether an address has been Blocked\r\n   *\r\n   * @param account The account to check\r\n   */\r\n  function _isAllowed(address account) internal view returns (bool) {\r\n    return allowlist.isAllowed(account);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20Upgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  IERC20Upgradeable,\r\n  IERC20MetadataUpgradeable\r\n{\r\n  mapping(address => uint256) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n\r\n  /**\r\n   * @dev Sets the values for {name} and {symbol}.\r\n   *\r\n   * The default value of {decimals} is 18. To select a different value for\r\n   * {decimals} you should overload it.\r\n   *\r\n   * All two of these values are immutable: they can only be set once during\r\n   * construction.\r\n   */\r\n  function __ERC20_init(string memory name_, string memory symbol_)\r\n    internal\r\n    onlyInitializing\r\n  {\r\n    __ERC20_init_unchained(name_, symbol_);\r\n  }\r\n\r\n  function __ERC20_init_unchained(string memory name_, string memory symbol_)\r\n    internal\r\n    onlyInitializing\r\n  {\r\n    _name = name_;\r\n    _symbol = symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() public view virtual override returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token, usually a shorter version of the\r\n   * name.\r\n   */\r\n  function symbol() public view virtual override returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals used to get its user representation.\r\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n   *\r\n   * Tokens usually opt for a value of 18, imitating the relationship between\r\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n   * overridden;\r\n   *\r\n   * NOTE: This information is only used for _display_ purposes: it in\r\n   * no way affects any of the arithmetic of the contract, including\r\n   * {IERC20-balanceOf} and {IERC20-transfer}.\r\n   */\r\n  function decimals() public view virtual override returns (uint8) {\r\n    return 18;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-totalSupply}.\r\n   */\r\n  function totalSupply() public view virtual override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-balanceOf}.\r\n   */\r\n  function balanceOf(address account)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address to, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    _transfer(owner, to, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-approve}.\r\n   *\r\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    _approve(owner, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {ERC20}.\r\n   *\r\n   * NOTE: Does not update the allowance if the current allowance\r\n   * is the maximum `uint256`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` and `to` cannot be the zero address.\r\n   * - `from` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for ``from``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    address spender = _msgSender();\r\n    _spendAllowance(from, spender, amount);\r\n    _transfer(from, to, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    uint256 currentAllowance = allowance(owner, spender);\r\n    require(\r\n      currentAllowance >= subtractedValue,\r\n      \"ERC20: decreased allowance below zero\"\r\n    );\r\n    unchecked {\r\n      _approve(owner, spender, currentAllowance - subtractedValue);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves `amount` of tokens from `from` to `to`.\r\n   *\r\n   * This internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `from` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(from != address(0), \"ERC20: transfer from the zero address\");\r\n    require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n    _beforeTokenTransfer(from, to, amount);\r\n\r\n    uint256 fromBalance = _balances[from];\r\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n    unchecked {\r\n      _balances[from] = fromBalance - amount;\r\n    }\r\n    _balances[to] += amount;\r\n\r\n    emit Transfer(from, to, amount);\r\n\r\n    _afterTokenTransfer(from, to, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   */\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    _totalSupply += amount;\r\n    _balances[account] += amount;\r\n    emit Transfer(address(0), account, amount);\r\n\r\n    _afterTokenTransfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, reducing the\r\n   * total supply.\r\n   *\r\n   * Emits a {Transfer} event with `to` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   * - `account` must have at least `amount` tokens.\r\n   */\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    uint256 accountBalance = _balances[account];\r\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n    unchecked {\r\n      _balances[account] = accountBalance - amount;\r\n    }\r\n    _totalSupply -= amount;\r\n\r\n    emit Transfer(account, address(0), amount);\r\n\r\n    _afterTokenTransfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n   *\r\n   * This internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n   *\r\n   * Does not update the allowance amount in case of infinite allowance.\r\n   * Revert if not enough allowance is available.\r\n   *\r\n   * Might emit an {Approval} event.\r\n   */\r\n  function _spendAllowance(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    uint256 currentAllowance = allowance(owner, spender);\r\n    if (currentAllowance != type(uint256).max) {\r\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n      unchecked {\r\n        _approve(owner, spender, currentAllowance - amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * will be transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n\r\n  /**\r\n   * @dev Hook that is called after any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * has been transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _afterTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[45] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20BurnableUpgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  ERC20Upgradeable\r\n{\r\n  function __ERC20Burnable_init() internal onlyInitializing {}\r\n\r\n  function __ERC20Burnable_init_unchained() internal onlyInitializing {}\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from the caller.\r\n   *\r\n   * See {ERC20-_burn}.\r\n   */\r\n  function burn(uint256 amount) public virtual {\r\n    _burn(_msgSender(), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n   * allowance.\r\n   *\r\n   * See {ERC20-_burn} and {ERC20-allowance}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have allowance for ``accounts``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function burnFrom(address account, uint256 amount) public virtual {\r\n    _spendAllowance(account, _msgSender(), amount);\r\n    _burn(account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev ERC20 token with pausable token transfers, minting and burning.\r\n *\r\n * Useful for scenarios such as preventing trades until the end of an evaluation\r\n * period, or having an emergency switch for freezing all token transfers in the\r\n * event of a large bug.\r\n */\r\nabstract contract ERC20PausableUpgradeable is\r\n  Initializable,\r\n  ERC20Upgradeable,\r\n  PausableUpgradeable\r\n{\r\n  function __ERC20Pausable_init() internal onlyInitializing {\r\n    __Pausable_init_unchained();\r\n  }\r\n\r\n  function __ERC20Pausable_init_unchained() internal onlyInitializing {}\r\n\r\n  /**\r\n   * @dev See {ERC20-_beforeTokenTransfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the contract must not be paused.\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual override {\r\n    super._beforeTokenTransfer(from, to, amount);\r\n\r\n    require(!paused(), \"ERC20Pausable: token transfer while paused\");\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\r\n */\r\nabstract contract AccessControlEnumerableUpgradeable is\r\n  Initializable,\r\n  IAccessControlEnumerableUpgradeable,\r\n  AccessControlUpgradeable\r\n{\r\n  function __AccessControlEnumerable_init() internal onlyInitializing {}\r\n\r\n  function __AccessControlEnumerable_init_unchained()\r\n    internal\r\n    onlyInitializing\r\n  {}\r\n\r\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n\r\n  mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns one of the accounts that have `role`. `index` must be a\r\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n   *\r\n   * Role bearers are not sorted in any particular way, and their ordering may\r\n   * change at any point.\r\n   *\r\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n   * you perform all queries on the same block. See the following\r\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n   * for more information.\r\n   */\r\n  function getRoleMember(bytes32 role, uint256 index)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (address)\r\n  {\r\n    return _roleMembers[role].at(index);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of accounts that have `role`. Can be used\r\n   * together with {getRoleMember} to enumerate all bearers of a role.\r\n   */\r\n  function getRoleMemberCount(bytes32 role)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _roleMembers[role].length();\r\n  }\r\n\r\n  /**\r\n   * @dev Overload {_grantRole} to track enumerable memberships\r\n   */\r\n  function _grantRole(bytes32 role, address account) internal virtual override {\r\n    super._grantRole(role, account);\r\n    _roleMembers[role].add(account);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload {_revokeRole} to track enumerable memberships\r\n   */\r\n  function _revokeRole(bytes32 role, address account)\r\n    internal\r\n    virtual\r\n    override\r\n  {\r\n    super._revokeRole(role, account);\r\n    _roleMembers[role].remove(account);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[49] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n  function __Context_init() internal onlyInitializing {}\r\n\r\n  function __Context_init_unchained() internal onlyInitializing {}\r\n\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `to`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `from` to `to` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the decimals places of the token.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\r\n  /**\r\n   * @dev Emitted when the pause is triggered by `account`.\r\n   */\r\n  event Paused(address account);\r\n\r\n  /**\r\n   * @dev Emitted when the pause is lifted by `account`.\r\n   */\r\n  event Unpaused(address account);\r\n\r\n  bool private _paused;\r\n\r\n  /**\r\n   * @dev Initializes the contract in unpaused state.\r\n   */\r\n  function __Pausable_init() internal onlyInitializing {\r\n    __Pausable_init_unchained();\r\n  }\r\n\r\n  function __Pausable_init_unchained() internal onlyInitializing {\r\n    _paused = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must not be paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    _requireNotPaused();\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must be paused.\r\n   */\r\n  modifier whenPaused() {\r\n    _requirePaused();\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the contract is paused, and false otherwise.\r\n   */\r\n  function paused() public view virtual returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if the contract is paused.\r\n   */\r\n  function _requireNotPaused() internal view virtual {\r\n    require(!paused(), \"Pausable: paused\");\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if the contract is not paused.\r\n   */\r\n  function _requirePaused() internal view virtual {\r\n    require(paused(), \"Pausable: not paused\");\r\n  }\r\n\r\n  /**\r\n   * @dev Triggers stopped state.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must not be paused.\r\n   */\r\n  function _pause() internal virtual whenNotPaused {\r\n    _paused = true;\r\n    emit Paused(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns to normal state.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must be paused.\r\n   */\r\n  function _unpause() internal virtual whenPaused {\r\n    _paused = false;\r\n    emit Unpaused(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[49] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IAccessControlUpgradeable.sol\";\r\n\r\n/**\r\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\r\n */\r\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\r\n  /**\r\n   * @dev Returns one of the accounts that have `role`. `index` must be a\r\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n   *\r\n   * Role bearers are not sorted in any particular way, and their ordering may\r\n   * change at any point.\r\n   *\r\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n   * you perform all queries on the same block. See the following\r\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n   * for more information.\r\n   */\r\n  function getRoleMember(bytes32 role, uint256 index)\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns the number of accounts that have `role`. Can be used\r\n   * together with {getRoleMember} to enumerate all bearers of a role.\r\n   */\r\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ERC165Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControlUpgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  IAccessControlUpgradeable,\r\n  ERC165Upgradeable\r\n{\r\n  function __AccessControl_init() internal onlyInitializing {}\r\n\r\n  function __AccessControl_init_unchained() internal onlyInitializing {}\r\n\r\n  struct RoleData {\r\n    mapping(address => bool) members;\r\n    bytes32 adminRole;\r\n  }\r\n\r\n  mapping(bytes32 => RoleData) private _roles;\r\n\r\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n  /**\r\n   * @dev Modifier that checks that an account has a specific role. Reverts\r\n   * with a standardized message including the required role.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n   *\r\n   * _Available since v4.1._\r\n   */\r\n  modifier onlyRole(bytes32 role) {\r\n    _checkRole(role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IAccessControlUpgradeable).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns `true` if `account` has been granted `role`.\r\n   */\r\n  function hasRole(bytes32 role, address account)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return _roles[role].members[account];\r\n  }\r\n\r\n  /**\r\n   * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n   * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n   *\r\n   * Format of the revert message is described in {_checkRole}.\r\n   *\r\n   * _Available since v4.6._\r\n   */\r\n  function _checkRole(bytes32 role) internal view virtual {\r\n    _checkRole(role, _msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Revert with a standard message if `account` is missing `role`.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n   */\r\n  function _checkRole(bytes32 role, address account) internal view virtual {\r\n    if (!hasRole(role, account)) {\r\n      revert(\r\n        string(\r\n          abi.encodePacked(\r\n            \"AccessControl: account \",\r\n            StringsUpgradeable.toHexString(uint160(account), 20),\r\n            \" is missing role \",\r\n            StringsUpgradeable.toHexString(uint256(role), 32)\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n   * {revokeRole}.\r\n   *\r\n   * To change a role's admin, use {_setRoleAdmin}.\r\n   */\r\n  function getRoleAdmin(bytes32 role)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bytes32)\r\n  {\r\n    return _roles[role].adminRole;\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   *\r\n   * May emit a {RoleGranted} event.\r\n   */\r\n  function grantRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   *\r\n   * May emit a {RoleRevoked} event.\r\n   */\r\n  function revokeRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from the calling account.\r\n   *\r\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n   * purpose is to provide a mechanism for accounts to lose their privileges\r\n   * if they are compromised (such as when a trusted device is misplaced).\r\n   *\r\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must be `account`.\r\n   *\r\n   * May emit a {RoleRevoked} event.\r\n   */\r\n  function renounceRole(bytes32 role, address account) public virtual override {\r\n    require(\r\n      account == _msgSender(),\r\n      \"AccessControl: can only renounce roles for self\"\r\n    );\r\n\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event. Note that unlike {grantRole}, this function doesn't perform any\r\n   * checks on the calling account.\r\n   *\r\n   * May emit a {RoleGranted} event.\r\n   *\r\n   * [WARNING]\r\n   * ====\r\n   * This function should only be called from the constructor when setting\r\n   * up the initial roles for the system.\r\n   *\r\n   * Using this function in any other way is effectively circumventing the admin\r\n   * system imposed by {AccessControl}.\r\n   * ====\r\n   *\r\n   * NOTE: This function is deprecated in favor of {_grantRole}.\r\n   */\r\n  function _setupRole(bytes32 role, address account) internal virtual {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `adminRole` as ``role``'s admin role.\r\n   *\r\n   * Emits a {RoleAdminChanged} event.\r\n   */\r\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n    bytes32 previousAdminRole = getRoleAdmin(role);\r\n    _roles[role].adminRole = adminRole;\r\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * Internal function without access restriction.\r\n   *\r\n   * May emit a {RoleGranted} event.\r\n   */\r\n  function _grantRole(bytes32 role, address account) internal virtual {\r\n    if (!hasRole(role, account)) {\r\n      _roles[role].members[account] = true;\r\n      emit RoleGranted(role, account, _msgSender());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * Internal function without access restriction.\r\n   *\r\n   * May emit a {RoleRevoked} event.\r\n   */\r\n  function _revokeRole(bytes32 role, address account) internal virtual {\r\n    if (hasRole(role, account)) {\r\n      _roles[role].members[account] = false;\r\n      emit RoleRevoked(role, account, _msgSender());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[49] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\r\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSetUpgradeable {\r\n  // To implement this library for multiple types with as little code\r\n  // repetition as possible, we write it in terms of a generic Set type with\r\n  // bytes32 values.\r\n  // The Set implementation uses private functions, and user-facing\r\n  // implementations (such as AddressSet) are just wrappers around the\r\n  // underlying Set.\r\n  // This means that we can only create new EnumerableSets for types that fit\r\n  // in bytes32.\r\n\r\n  struct Set {\r\n    // Storage of set values\r\n    bytes32[] _values;\r\n    // Position of the value in the `values` array, plus 1 because index 0\r\n    // means a value is not in the set.\r\n    mapping(bytes32 => uint256) _indexes;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function _add(Set storage set, bytes32 value) private returns (bool) {\r\n    if (!_contains(set, value)) {\r\n      set._values.push(value);\r\n      // The value is stored at length-1, but we add 1 to all indexes\r\n      // and use 0 as a sentinel value\r\n      set._indexes[value] = set._values.length;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n    // We read and store the value's index to prevent multiple reads from the same storage slot\r\n    uint256 valueIndex = set._indexes[value];\r\n\r\n    if (valueIndex != 0) {\r\n      // Equivalent to contains(set, value)\r\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n      // This modifies the order of the array, as noted in {at}.\r\n\r\n      uint256 toDeleteIndex = valueIndex - 1;\r\n      uint256 lastIndex = set._values.length - 1;\r\n\r\n      if (lastIndex != toDeleteIndex) {\r\n        bytes32 lastValue = set._values[lastIndex];\r\n\r\n        // Move the last value to the index where the value to delete is\r\n        set._values[toDeleteIndex] = lastValue;\r\n        // Update the index for the moved value\r\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n      }\r\n\r\n      // Delete the slot where the moved value was stored\r\n      set._values.pop();\r\n\r\n      // Delete the index for the deleted slot\r\n      delete set._indexes[value];\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function _contains(Set storage set, bytes32 value)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return set._indexes[value] != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function _length(Set storage set) private view returns (uint256) {\r\n    return set._values.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n    return set._values[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function _values(Set storage set) private view returns (bytes32[] memory) {\r\n    return set._values;\r\n  }\r\n\r\n  // Bytes32Set\r\n\r\n  struct Bytes32Set {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _add(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(Bytes32Set storage set, bytes32 value)\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return _remove(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(Bytes32Set storage set, bytes32 value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(Bytes32Set storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(Bytes32Set storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return _at(set._inner, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(Bytes32Set storage set)\r\n    internal\r\n    view\r\n    returns (bytes32[] memory)\r\n  {\r\n    return _values(set._inner);\r\n  }\r\n\r\n  // AddressSet\r\n\r\n  struct AddressSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(AddressSet storage set, address value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(AddressSet storage set, address value)\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(AddressSet storage set, address value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(AddressSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(AddressSet storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(uint160(uint256(_at(set._inner, index))));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(AddressSet storage set)\r\n    internal\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    bytes32[] memory store = _values(set._inner);\r\n    address[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // UintSet\r\n\r\n  struct UintSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(UintSet storage set, uint256 value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function length(UintSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(UintSet storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return uint256(_at(set._inner, index));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(UintSet storage set)\r\n    internal\r\n    view\r\n    returns (uint256[] memory)\r\n  {\r\n    bytes32[] memory store = _values(set._inner);\r\n    uint256[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControlUpgradeable {\r\n  /**\r\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n   *\r\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n   * {RoleAdminChanged} not being emitted signaling this.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  event RoleAdminChanged(\r\n    bytes32 indexed role,\r\n    bytes32 indexed previousAdminRole,\r\n    bytes32 indexed newAdminRole\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is granted `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call, an admin role\r\n   * bearer except when using {AccessControl-_setupRole}.\r\n   */\r\n  event RoleGranted(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is revoked `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call:\r\n   *   - if using `revokeRole`, it is the admin role bearer\r\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n   */\r\n  event RoleRevoked(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Returns `true` if `account` has been granted `role`.\r\n   */\r\n  function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n   * {revokeRole}.\r\n   *\r\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n   */\r\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function grantRole(bytes32 role, address account) external;\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function revokeRole(bytes32 role, address account) external;\r\n\r\n  /**\r\n   * @dev Revokes `role` from the calling account.\r\n   *\r\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n   * purpose is to provide a mechanism for accounts to lose their privileges\r\n   * if they are compromised (such as when a trusted device is misplaced).\r\n   *\r\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must be `account`.\r\n   */\r\n  function renounceRole(bytes32 role, address account) external;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary StringsUpgradeable {\r\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n  uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return \"0x00\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(uint256 value, uint256 length)\r\n    internal\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = \"0\";\r\n    buffer[1] = \"x\";\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, \"Strings: hex length insufficient\");\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(address addr) internal pure returns (string memory) {\r\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/IERC165Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\r\n  function __ERC165_init() internal onlyInitializing {}\r\n\r\n  function __ERC165_init_unchained() internal onlyInitializing {}\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return interfaceId == type(IERC165Upgradeable).interfaceId;\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165Upgradeable {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IBlocklist.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IBlocklist {\r\n  function addToBlocklist(address[] calldata accounts) external;\r\n\r\n  function removeFromBlocklist(address[] calldata accounts) external;\r\n\r\n  function isBlocked(address account) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Event emitted when addresses are added to the blocklist\r\n   *\r\n   * @param accounts The addresses that were added to the blocklist\r\n   */\r\n  event BlockedAddressesAdded(address[] accounts);\r\n\r\n  /**\r\n   * @notice Event emitted when addresses are removed from the blocklist\r\n   *\r\n   * @param accounts The addresses that were removed from the blocklist\r\n   */\r\n  event BlockedAddressesRemoved(address[] accounts);\r\n}\r\n"
    },
    "contracts/interfaces/IBlocklistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IBlocklist.sol\";\r\n\r\n/**\r\n * @title IBlocklistClient\r\n * @author Ondo Finance\r\n * @notice The client interface for the Blocklist contract.\r\n */\r\ninterface IBlocklistClient {\r\n  /// @notice Returns reference to the blocklist that this client queries\r\n  function blocklist() external view returns (IBlocklist);\r\n\r\n  /// @notice Sets the blocklist reference\r\n  function setBlocklist(address registry) external;\r\n\r\n  /// @notice Error for when caller attempts to set the blocklist reference\r\n  ///         to the zero address\r\n  error BlocklistZeroAddress();\r\n\r\n  /// @notice Error for when caller attempts to perform action on a blocked\r\n  ///         account\r\n  error BlockedAccount();\r\n\r\n  /**\r\n   * @dev Event for when the blocklist reference is set\r\n   *\r\n   * @param oldBlocklist The old blocklist\r\n   * @param newBlocklist The new blocklist\r\n   */\r\n  event BlocklistSet(address oldBlocklist, address newBlocklist);\r\n}\r\n"
    },
    "contracts/interfaces/IAllowlist.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IAllowlist {\r\n  function addTerm(string calldata term) external;\r\n\r\n  function setCurrentTermIndex(uint256 _currentTermIndex) external;\r\n\r\n  function setValidTermIndexes(uint256[] calldata indexes) external;\r\n\r\n  function isAllowed(address account) external view returns (bool);\r\n\r\n  function getCurrentTerm() external view returns (string memory);\r\n\r\n  function getValidTermIndexes() external view returns (uint256[] memory);\r\n\r\n  function addAccountToAllowlist(\r\n    uint256 _currentTermIndex,\r\n    address account,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  function addSelfToAllowlist(uint256 termIndex) external;\r\n\r\n  function setAccountStatus(\r\n    address account,\r\n    uint256 termIndex,\r\n    bool status\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Event emitted when a term is added\r\n   *\r\n   * @param hashedMessage The hash of the terms string that was added\r\n   * @param termIndex     The index of the term that was added\r\n   */\r\n  event TermAdded(bytes32 hashedMessage, uint256 termIndex);\r\n\r\n  /**\r\n   * @notice Event emitted when the current term index is set\r\n   *\r\n   * @param oldIndex The old current term index\r\n   * @param newIndex The new current term index\r\n   */\r\n  event CurrentTermIndexSet(uint256 oldIndex, uint256 newIndex);\r\n\r\n  /**\r\n   * @notice Event emitted when the valid term indexes are set\r\n   *\r\n   * @param oldIndexes The old valid term indexes\r\n   * @param newIndexes The new valid term indexes\r\n   */\r\n  event ValidTermIndexesSet(uint256[] oldIndexes, uint256[] newIndexes);\r\n\r\n  /**\r\n   * @notice Event emitted when an accoun status is set by an admin\r\n   *\r\n   * @param account   The account whose status was set\r\n   * @param termIndex The term index of the account whose status that was set\r\n   * @param status    The new status of the account\r\n   */\r\n  event AccountStatusSetByAdmin(\r\n    address indexed account,\r\n    uint256 indexed termIndex,\r\n    bool status\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when an account adds itself added to the allowlist\r\n   *\r\n   * @param account   The account that was added\r\n   * @param termIndex The term index for which the account was added\r\n   */\r\n  event AccountAddedSelf(address indexed account, uint256 indexed termIndex);\r\n\r\n  /**\r\n   * @notice Event emitted when an account is added to the allowlist by a signature\r\n   *\r\n   * @param account   The account that was added\r\n   * @param termIndex The term index for which the account was added\r\n   * @param v         The v value of the signature\r\n   * @param r         The r value of the signature\r\n   * @param s         The s value of the signature\r\n   */\r\n  event AccountAddedFromSignature(\r\n    address indexed account,\r\n    uint256 indexed termIndex,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when an account status is set\r\n   *\r\n   * @param account   The account whose status was set\r\n   * @param termIndex The term index of the account whose status was set\r\n   * @param status    The new status of the account\r\n   */\r\n  event AccountStatusSet(\r\n    address indexed account,\r\n    uint256 indexed termIndex,\r\n    bool status\r\n  );\r\n\r\n  /// ERRORS ///\r\n  error InvalidTermIndex();\r\n  error InvalidVSignature();\r\n  error AlreadyVerified();\r\n  error InvalidSigner();\r\n}\r\n"
    },
    "contracts/interfaces/IAllowlistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IAllowlist.sol\";\r\n\r\n/**\r\n * @title IAllowlistClient\r\n * @author Ondo Finance\r\n * @notice The client interface for Ondo's Allowlist contract.\r\n */\r\ninterface IAllowlistClient {\r\n  /// @notice Returns reference to the allowlist that this client queries\r\n  function allowlist() external view returns (IAllowlist);\r\n\r\n  /// @notice Sets the allowlist contract reference\r\n  function setAllowlist(address allowlist) external;\r\n\r\n  /**\r\n   * @dev Event for when the allowlist reference is set\r\n   *\r\n   * @param oldAllowlist The old allowlist\r\n   * @param newAllowlist The new allowlist\r\n   */\r\n  event AllowlistSet(address oldAllowlist, address newAllowlist);\r\n\r\n  /// @notice Error for when caller attempts to set the allowlist reference\r\n  ///         to the zero address.\r\n  error AllowlistZeroAddress();\r\n}\r\n"
    },
    "contracts/usdy/USDYFactory.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\n// Proxy admin contract used in OZ upgrades plugin\r\nimport \"contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\r\nimport \"contracts/Proxy.sol\";\r\nimport \"contracts/usdy/USDY.sol\";\r\nimport \"contracts/interfaces/IMulticall.sol\";\r\n\r\n/**\r\n * @title USDYFactory\r\n * @author Ondo Finance\r\n * @notice This contract serves as a Factory for the upgradable USDY token contract.\r\n *         Upon calling `deployUSDY` the `guardian` address (set in constructor) will\r\n *         deploy the following:\r\n *         1) USDY - The implementation contract, ERC20 contract with the initializer disabled\r\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\r\n *                         @notice Owner is set to `guardian` address.\r\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\r\n *                                          `_logic' is set to `address(cash)`.\r\n *\r\n *         Following the above mentioned deployment, the address of the CashFactory contract will:\r\n *         i) Grant the `DEFAULT_ADMIN_ROLE` & PAUSER_ROLE to the `guardian` address\r\n *         ii) Revoke the `MINTER_ROLE`, `PAUSER_ROLE` & `DEFAULT_ADMIN_ROLE` from address(this).\r\n *         iii) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\r\n *\r\n * @notice `guardian` address in constructor is a msig.\r\n */\r\ncontract USDYFactory is IMulticall {\r\n  struct USDYListData {\r\n    address blocklist;\r\n    address allowlist;\r\n    address sanctionsList;\r\n  }\r\n\r\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\r\n\r\n  address internal immutable guardian;\r\n  USDY public usdyImplementation;\r\n  ProxyAdmin public usdyProxyAdmin;\r\n  TokenProxy public usdyProxy;\r\n\r\n  constructor(address _guardian) {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev This function will deploy an upgradable instance of USDY\r\n   *\r\n   * @param name   The name of the token we want to deploy.\r\n   * @param ticker The ticker for the token we want to deploy.\r\n   *\r\n   * @return address The address of the proxy contract.\r\n   * @return address The address of the proxyAdmin contract.\r\n   * @return address The address of the implementation contract.\r\n   *\r\n   * @notice 1) Will automatically revoke all deployer roles granted to\r\n   *            address(this).\r\n   *         2) Will grant DEFAULT_ADMIN & PAUSER_ROLE(S) to `guardian`\r\n   *            address specified in constructor.\r\n   *         3) Will transfer ownership of the proxyAdmin to guardian\r\n   *            address.\r\n   *\r\n   */\r\n  function deployUSDY(\r\n    string calldata name,\r\n    string calldata ticker,\r\n    USDYListData calldata listData\r\n  ) external onlyGuardian returns (address, address, address) {\r\n    usdyImplementation = new USDY();\r\n    usdyProxyAdmin = new ProxyAdmin();\r\n    usdyProxy = new TokenProxy(\r\n      address(usdyImplementation),\r\n      address(usdyProxyAdmin),\r\n      \"\"\r\n    );\r\n    USDY usdyProxied = USDY(address(usdyProxy));\r\n    usdyProxied.initialize(\r\n      name,\r\n      ticker,\r\n      listData.blocklist,\r\n      listData.allowlist,\r\n      listData.sanctionsList\r\n    );\r\n\r\n    usdyProxied.grantRole(DEFAULT_ADMIN_ROLE, guardian);\r\n    usdyProxied.grantRole(PAUSER_ROLE, guardian);\r\n\r\n    usdyProxied.revokeRole(MINTER_ROLE, address(this));\r\n    usdyProxied.revokeRole(PAUSER_ROLE, address(this));\r\n    usdyProxied.revokeRole(DEFAULT_ADMIN_ROLE, address(this));\r\n\r\n    usdyProxyAdmin.transferOwnership(guardian);\r\n    assert(usdyProxyAdmin.owner() == guardian);\r\n    emit USDYDeployed(\r\n      address(usdyProxied),\r\n      address(usdyProxyAdmin),\r\n      address(usdyImplementation),\r\n      name,\r\n      ticker,\r\n      listData\r\n    );\r\n\r\n    return (\r\n      address(usdyProxied),\r\n      address(usdyProxyAdmin),\r\n      address(usdyImplementation)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for arbitrary batched calls\r\n   *\r\n   * @dev All external calls made through this function will\r\n   *      msg.sender == contract address\r\n   *\r\n   * @param exCallData Struct consisting of\r\n   *       1) target - contract to call\r\n   *       2) data - data to call target with\r\n   *       3) value - eth value to call target with\r\n   */\r\n  function multiexcall(\r\n    ExCallData[] calldata exCallData\r\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\r\n    results = new bytes[](exCallData.length);\r\n    for (uint256 i = 0; i < exCallData.length; ++i) {\r\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\r\n        value: exCallData[i].value\r\n      }(exCallData[i].data);\r\n      require(success, \"Call Failed\");\r\n      results[i] = ret;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Event emitted when upgradable USDY is deployed\r\n   *\r\n   * @param proxy             The address for the proxy contract\r\n   * @param proxyAdmin        The address for the proxy admin contract\r\n   * @param implementation    The address for the implementation contract\r\n   */\r\n  event USDYDeployed(\r\n    address proxy,\r\n    address proxyAdmin,\r\n    address implementation,\r\n    string name,\r\n    string ticker,\r\n    USDYListData listData\r\n  );\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"USDYFactory: You are not the Guardian\");\r\n    _;\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\r\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\r\n */\r\ncontract ProxyAdmin is Ownable {\r\n  /**\r\n   * @dev Returns the current implementation of `proxy`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - This contract must be the admin of `proxy`.\r\n   */\r\n  function getProxyImplementation(TransparentUpgradeableProxy proxy)\r\n    public\r\n    view\r\n    virtual\r\n    returns (address)\r\n  {\r\n    // We need to manually run the static call since the getter cannot be flagged as view\r\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\r\n    (bool success, bytes memory returndata) =\r\n      address(proxy).staticcall(hex\"5c60da1b\");\r\n    require(success);\r\n    return abi.decode(returndata, (address));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current admin of `proxy`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - This contract must be the admin of `proxy`.\r\n   */\r\n  function getProxyAdmin(TransparentUpgradeableProxy proxy)\r\n    public\r\n    view\r\n    virtual\r\n    returns (address)\r\n  {\r\n    // We need to manually run the static call since the getter cannot be flagged as view\r\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\r\n    (bool success, bytes memory returndata) =\r\n      address(proxy).staticcall(hex\"f851a440\");\r\n    require(success);\r\n    return abi.decode(returndata, (address));\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of `proxy` to `newAdmin`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - This contract must be the current admin of `proxy`.\r\n   */\r\n  function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin)\r\n    public\r\n    virtual\r\n    onlyOwner\r\n  {\r\n    proxy.changeAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - This contract must be the admin of `proxy`.\r\n   */\r\n  function upgrade(TransparentUpgradeableProxy proxy, address implementation)\r\n    public\r\n    virtual\r\n    onlyOwner\r\n  {\r\n    proxy.upgradeTo(implementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\r\n   * {TransparentUpgradeableProxy-upgradeToAndCall}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - This contract must be the admin of `proxy`.\r\n   */\r\n  function upgradeAndCall(\r\n    TransparentUpgradeableProxy proxy,\r\n    address implementation,\r\n    bytes memory data\r\n  ) public payable virtual onlyOwner {\r\n    proxy.upgradeToAndCall{value: msg.value}(implementation, data);\r\n  }\r\n}\r\n"
    },
    "contracts/Proxy.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract TokenProxy is TransparentUpgradeableProxy {\r\n  constructor(\r\n    address _logic,\r\n    address _admin,\r\n    bytes memory _data\r\n  ) TransparentUpgradeableProxy(_logic, _admin, _data) {}\r\n}\r\n"
    },
    "contracts/interfaces/IMulticall.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title IMulticall\r\n * @author Ondo Finance\r\n * @notice This interface dictates the required external functions for Ondo's\r\n *         multicall contract.\r\n */\r\ninterface IMulticall {\r\n  /// @dev External call data structure\r\n  struct ExCallData {\r\n    // The contract we intend to call\r\n    address target;\r\n    // The encoded function data for the call\r\n    bytes data;\r\n    // The ether value to be sent in the call\r\n    uint256 value;\r\n  }\r\n\r\n  /**\r\n   * @notice Batches multiple function calls to different target contracts\r\n   *         and returns the resulting data provided all calls were successful\r\n   *\r\n   * @dev The `msg.sender` is always the contract from which this function\r\n   *      is being called\r\n   *\r\n   * @param exdata The ExCallData struct array containing the information\r\n   *               regarding which contract to call, what data to call with,\r\n   *               and what ether value to send along with the call\r\n   *\r\n   * @return results The resulting data returned from each call made\r\n   */\r\n  function multiexcall(\r\n    ExCallData[] calldata exdata\r\n  ) external payable returns (bytes[] memory results);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/proxy/ERC1967Proxy.sol\";\r\n\r\n/**\r\n * @dev This contract implements a proxy that is upgradeable by an admin.\r\n *\r\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\r\n * clashing], which can potentially be used in an attack, this contract uses the\r\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\r\n * things that go hand in hand:\r\n *\r\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\r\n * that call matches one of the admin functions exposed by the proxy itself.\r\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\r\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\r\n * \"admin cannot fallback to proxy target\".\r\n *\r\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\r\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\r\n * to sudden errors when trying to call a function from the proxy implementation.\r\n *\r\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\r\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\r\n */\r\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\r\n  /**\r\n   * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\r\n   * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\r\n   */\r\n  constructor(\r\n    address _logic,\r\n    address admin_,\r\n    bytes memory _data\r\n  ) payable ERC1967Proxy(_logic, _data) {\r\n    assert(\r\n      _ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\r\n    );\r\n    _changeAdmin(admin_);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\r\n   */\r\n  modifier ifAdmin() {\r\n    if (msg.sender == _getAdmin()) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current admin.\r\n   *\r\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\r\n   *\r\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n   * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\r\n   */\r\n  function admin() external ifAdmin returns (address admin_) {\r\n    admin_ = _getAdmin();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current implementation.\r\n   *\r\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\r\n   *\r\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n   * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\r\n   */\r\n  function implementation() external ifAdmin returns (address implementation_) {\r\n    implementation_ = _implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of the proxy.\r\n   *\r\n   * Emits an {AdminChanged} event.\r\n   *\r\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\r\n   */\r\n  function changeAdmin(address newAdmin) external virtual ifAdmin {\r\n    _changeAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the implementation of the proxy.\r\n   *\r\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\r\n   */\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeToAndCall(newImplementation, bytes(\"\"), false);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\r\n   * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\r\n   * proxied contract.\r\n   *\r\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\r\n   */\r\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n    external\r\n    payable\r\n    ifAdmin\r\n  {\r\n    _upgradeToAndCall(newImplementation, data, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current admin.\r\n   */\r\n  function _admin() internal view virtual returns (address) {\r\n    return _getAdmin();\r\n  }\r\n\r\n  /**\r\n   * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\r\n   */\r\n  function _beforeFallback() internal virtual override {\r\n    require(\r\n      msg.sender != _getAdmin(),\r\n      \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\"\r\n    );\r\n    super._beforeFallback();\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _transferOwnership(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    _transferOwnership(address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Internal function without access restriction.\r\n   */\r\n  function _transferOwnership(address newOwner) internal virtual {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/proxy/Proxy.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/proxy/ERC1967Upgrade.sol\";\r\n\r\n/**\r\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\r\n * implementation address that can be changed. This address is stored in storage in the location specified by\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\r\n * implementation behind the proxy.\r\n */\r\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\r\n  /**\r\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\r\n   *\r\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\r\n   * function call, and allows initializating the storage of the proxy like a Solidity constructor.\r\n   */\r\n  constructor(address _logic, bytes memory _data) payable {\r\n    assert(\r\n      _IMPLEMENTATION_SLOT ==\r\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\r\n    );\r\n    _upgradeToAndCall(_logic, _data, false);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current implementation address.\r\n   */\r\n  function _implementation()\r\n    internal\r\n    view\r\n    virtual\r\n    override\r\n    returns (address impl)\r\n  {\r\n    return ERC1967Upgrade._getImplementation();\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n *\r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n  /**\r\n   * @dev Delegates the current call to `implementation`.\r\n   *\r\n   * This function does not return to its internal call site, it will return directly to the external caller.\r\n   */\r\n  function _delegate(address implementation) internal virtual {\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize())\r\n\r\n      // Call the implementation.\r\n      // out and outsize are 0 because we don't know the size yet.\r\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n      // Copy the returned data.\r\n      returndatacopy(0, 0, returndatasize())\r\n\r\n      switch result\r\n        // delegatecall returns 0 on error.\r\n        case 0 {\r\n          revert(0, returndatasize())\r\n        }\r\n        default {\r\n          return(0, returndatasize())\r\n        }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\r\n   * and {_fallback} should delegate.\r\n   */\r\n  function _implementation() internal view virtual returns (address);\r\n\r\n  /**\r\n   * @dev Delegates the current call to the address returned by `_implementation()`.\r\n   *\r\n   * This function does not return to its internall call site, it will return directly to the external caller.\r\n   */\r\n  function _fallback() internal virtual {\r\n    _beforeFallback();\r\n    _delegate(_implementation());\r\n  }\r\n\r\n  /**\r\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n   * function in the contract matches the call data.\r\n   */\r\n  fallback() external payable {\r\n    _fallback();\r\n  }\r\n\r\n  /**\r\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n   * is empty.\r\n   */\r\n  receive() external payable {\r\n    _fallback();\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n   * call, or as part of the Solidity `fallback` or `receive` functions.\r\n   *\r\n   * If overriden should call `super._beforeFallback()`.\r\n   */\r\n  function _beforeFallback() internal virtual {}\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/proxy/IBeacon.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/proxy/draft-IERC1822.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/Address.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/StorageSlot.sol\";\r\n\r\n/**\r\n * @dev This abstract contract provides getters and event emitting update functions for\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\r\n *\r\n * _Available since v4.1._\r\n *\r\n * @custom:oz-upgrades-unsafe-allow delegatecall\r\n */\r\nabstract contract ERC1967Upgrade {\r\n  // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n  bytes32 private constant _ROLLBACK_SLOT =\r\n    0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n  /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 internal constant _IMPLEMENTATION_SLOT =\r\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n  /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   */\r\n  event Upgraded(address indexed implementation);\r\n\r\n  /**\r\n   * @dev Returns the current implementation address.\r\n   */\r\n  function _getImplementation() internal view returns (address) {\r\n    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n  }\r\n\r\n  /**\r\n   * @dev Stores a new address in the EIP1967 implementation slot.\r\n   */\r\n  function _setImplementation(address newImplementation) private {\r\n    require(\r\n      Address.isContract(newImplementation),\r\n      \"ERC1967: new implementation is not a contract\"\r\n    );\r\n    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n  }\r\n\r\n  /**\r\n   * @dev Perform implementation upgrade\r\n   *\r\n   * Emits an {Upgraded} event.\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    _setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Perform implementation upgrade with additional setup call.\r\n   *\r\n   * Emits an {Upgraded} event.\r\n   */\r\n  function _upgradeToAndCall(\r\n    address newImplementation,\r\n    bytes memory data,\r\n    bool forceCall\r\n  ) internal {\r\n    _upgradeTo(newImplementation);\r\n    if (data.length > 0 || forceCall) {\r\n      Address.functionDelegateCall(newImplementation, data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n   *\r\n   * Emits an {Upgraded} event.\r\n   */\r\n  function _upgradeToAndCallUUPS(\r\n    address newImplementation,\r\n    bytes memory data,\r\n    bool forceCall\r\n  ) internal {\r\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\r\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\r\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\r\n    if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n      _setImplementation(newImplementation);\r\n    } else {\r\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (\r\n        bytes32 slot\r\n      ) {\r\n        require(\r\n          slot == _IMPLEMENTATION_SLOT,\r\n          \"ERC1967Upgrade: unsupported proxiableUUID\"\r\n        );\r\n      } catch {\r\n        revert(\"ERC1967Upgrade: new implementation is not UUPS\");\r\n      }\r\n      _upgradeToAndCall(newImplementation, data, forceCall);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 internal constant _ADMIN_SLOT =\r\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n  /**\r\n   * @dev Emitted when the admin account has changed.\r\n   */\r\n  event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n  /**\r\n   * @dev Returns the current admin.\r\n   */\r\n  function _getAdmin() internal view returns (address) {\r\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\r\n  }\r\n\r\n  /**\r\n   * @dev Stores a new address in the EIP1967 admin slot.\r\n   */\r\n  function _setAdmin(address newAdmin) private {\r\n    require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of the proxy.\r\n   *\r\n   * Emits an {AdminChanged} event.\r\n   */\r\n  function _changeAdmin(address newAdmin) internal {\r\n    emit AdminChanged(_getAdmin(), newAdmin);\r\n    _setAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n   */\r\n  bytes32 internal constant _BEACON_SLOT =\r\n    0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n  /**\r\n   * @dev Emitted when the beacon is upgraded.\r\n   */\r\n  event BeaconUpgraded(address indexed beacon);\r\n\r\n  /**\r\n   * @dev Returns the current beacon.\r\n   */\r\n  function _getBeacon() internal view returns (address) {\r\n    return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\r\n  }\r\n\r\n  /**\r\n   * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n   */\r\n  function _setBeacon(address newBeacon) private {\r\n    require(\r\n      Address.isContract(newBeacon),\r\n      \"ERC1967: new beacon is not a contract\"\r\n    );\r\n    require(\r\n      Address.isContract(IBeacon(newBeacon).implementation()),\r\n      \"ERC1967: beacon implementation is not a contract\"\r\n    );\r\n    StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n  }\r\n\r\n  /**\r\n   * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n   * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n   *\r\n   * Emits a {BeaconUpgraded} event.\r\n   */\r\n  function _upgradeBeaconToAndCall(\r\n    address newBeacon,\r\n    bytes memory data,\r\n    bool forceCall\r\n  ) internal {\r\n    _setBeacon(newBeacon);\r\n    emit BeaconUpgraded(newBeacon);\r\n    if (data.length > 0 || forceCall) {\r\n      Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeacon {\r\n  /**\r\n   * @dev Must return an address that can be used as a delegate call target.\r\n   *\r\n   * {BeaconProxy} will check that this address is a contract.\r\n   */\r\n  function implementation() external view returns (address);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\r\n * proxy whose upgrades are fully controlled by the current implementation.\r\n */\r\ninterface IERC1822Proxiable {\r\n  /**\r\n   * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\r\n   * address.\r\n   *\r\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n   * function revert if invoked through a proxy.\r\n   */\r\n  function proxiableUUID() external view returns (bytes32);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n   *\r\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n   * constructor.\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize/address.code.length, which returns 0\r\n    // for contracts in construction, since the code is only stored at the end\r\n    // of the constructor execution.\r\n\r\n    return account.code.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n    (bool success, ) = recipient.call{value: amount}(\"\");\r\n    require(\r\n      success,\r\n      \"Address: unable to send value, recipient may have reverted\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain `call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   *\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   *\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `target` must be a contract.\r\n   * - calling `target` with `data` must not revert.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return functionCall(target, data, \"Address: low-level call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n   * `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but also transferring `value` wei to `target`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the calling contract must have an ETH balance of at least `value`.\r\n   * - the called Solidity function must be `payable`.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        \"Address: low-level call with value failed\"\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      \"Address: insufficient balance for call\"\r\n    );\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionDelegateCall(\r\n        target,\r\n        data,\r\n        \"Address: low-level delegate call failed\"\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n   * revert reason using the provided one.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\r\n */\r\nlibrary StorageSlot {\r\n  struct AddressSlot {\r\n    address value;\r\n  }\r\n\r\n  struct BooleanSlot {\r\n    bool value;\r\n  }\r\n\r\n  struct Bytes32Slot {\r\n    bytes32 value;\r\n  }\r\n\r\n  struct Uint256Slot {\r\n    uint256 value;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n   */\r\n  function getAddressSlot(bytes32 slot)\r\n    internal\r\n    pure\r\n    returns (AddressSlot storage r)\r\n  {\r\n    assembly {\r\n      r.slot := slot\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n   */\r\n  function getBooleanSlot(bytes32 slot)\r\n    internal\r\n    pure\r\n    returns (BooleanSlot storage r)\r\n  {\r\n    assembly {\r\n      r.slot := slot\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n   */\r\n  function getBytes32Slot(bytes32 slot)\r\n    internal\r\n    pure\r\n    returns (Bytes32Slot storage r)\r\n  {\r\n    assembly {\r\n      r.slot := slot\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n   */\r\n  function getUint256Slot(bytes32 slot)\r\n    internal\r\n    pure\r\n    returns (Uint256Slot storage r)\r\n  {\r\n    assembly {\r\n      r.slot := slot\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n"
    },
    "contracts/usdy/allowlist/AllowlistFactory.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\n// Proxy admin contract used in OZ upgrades plugin\r\nimport \"contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\r\nimport \"contracts/usdy/allowlist/AllowlistProxy.sol\";\r\nimport \"contracts/usdy/allowlist/AllowlistUpgradeable.sol\";\r\nimport \"contracts/interfaces/IMulticall.sol\";\r\n\r\n/**\r\n * @title AllowlistFactory\r\n * @author Ondo Finance\r\n * @notice This contract serves as a Factory for the upgradable AllowlistUpgradeable contract.\r\n *         Upon calling `deployAllowlist` the `guardian` address (set in constructor) will\r\n *         deploy the following:\r\n *         1) AllowlistUpgradeable - The implementation contract.\r\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\r\n *                         @notice Owner is set to `guardian` address.\r\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\r\n *                                          `_logic' is set to `address(cash)`.\r\n *\r\n * @notice `guardian` address in constructor is a msig.\r\n */\r\ncontract AllowlistFactory is IMulticall {\r\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\r\n\r\n  address internal immutable guardian;\r\n  AllowlistUpgradeable public allowlistImplementation;\r\n  ProxyAdmin public allowlistProxyAdmin;\r\n  AllowlistProxy public allowlistProxy;\r\n\r\n  constructor(address _guardian) {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev This function will deploy an upgradable instance of AllowlistUpgradeable\r\n   *\r\n   * @param admin  The admin account for the AllowlistUpgradeable contract.\r\n   * @param setter The setter account for the AllowlistUpgradeable contract.\r\n   *\r\n   * @return address The address of the proxy contract.\r\n   * @return address The address of the proxyAdmin contract.\r\n   * @return address The address of the implementation contract.\r\n   *\r\n   */\r\n  function deployAllowlist(\r\n    address admin,\r\n    address setter\r\n  ) external onlyGuardian returns (address, address, address) {\r\n    allowlistImplementation = new AllowlistUpgradeable();\r\n\r\n    allowlistProxyAdmin = new ProxyAdmin();\r\n    allowlistProxy = new AllowlistProxy(\r\n      address(allowlistImplementation),\r\n      address(allowlistProxyAdmin),\r\n      \"\"\r\n    );\r\n    AllowlistUpgradeable allowlistProxied = AllowlistUpgradeable(\r\n      address(allowlistProxy)\r\n    );\r\n\r\n    allowlistProxied.initialize(admin, setter);\r\n\r\n    allowlistProxyAdmin.transferOwnership(guardian);\r\n    assert(allowlistProxyAdmin.owner() == guardian);\r\n    emit AllowlistDeployed(\r\n      address(allowlistProxied),\r\n      address(allowlistProxyAdmin),\r\n      address(allowlistImplementation)\r\n    );\r\n    return (\r\n      address(allowlistProxied),\r\n      address(allowlistProxyAdmin),\r\n      address(allowlistImplementation)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for arbitrary batched calls\r\n   *\r\n   * @dev All external calls made through this function will\r\n   *      msg.sender == contract address\r\n   *\r\n   * @param exCallData Struct consisting of\r\n   *       1) target - contract to call\r\n   *       2) data - data to call target with\r\n   *       3) value - eth value to call target with\r\n   */\r\n  function multiexcall(\r\n    ExCallData[] calldata exCallData\r\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\r\n    results = new bytes[](exCallData.length);\r\n    for (uint256 i = 0; i < exCallData.length; ++i) {\r\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\r\n        value: exCallData[i].value\r\n      }(exCallData[i].data);\r\n      require(success, \"Call Failed\");\r\n      results[i] = ret;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Event emitted when upgradable AllowlistUpgradeable is deployed\r\n   *\r\n   * @param proxy             The address for the proxy contract\r\n   * @param proxyAdmin        The address for the proxy admin contract\r\n   * @param implementation    The address for the implementation contract\r\n   */\r\n  event AllowlistDeployed(\r\n    address proxy,\r\n    address proxyAdmin,\r\n    address implementation\r\n  );\r\n\r\n  modifier onlyGuardian() {\r\n    require(\r\n      msg.sender == guardian,\r\n      \"AllowlistFactory: You are not the Guardian\"\r\n    );\r\n    _;\r\n  }\r\n}\r\n"
    },
    "contracts/usdy/allowlist/AllowlistProxy.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract AllowlistProxy is TransparentUpgradeableProxy {\r\n  constructor(\r\n    address _logic,\r\n    address _admin,\r\n    bytes memory _data\r\n  ) TransparentUpgradeableProxy(_logic, _admin, _data) {}\r\n}\r\n"
    },
    "contracts/usdy/allowlist/AllowlistUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\nimport \"contracts/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\nimport \"contracts/interfaces/IAllowlist.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\r\n\r\n/**\r\n * @title AllowlistUpgradeable\r\n * @author Ondo Finance\r\n * @notice This contract manages the allowlist status for accounts.\r\n */\r\ncontract AllowlistUpgradeable is\r\n  Initializable,\r\n  AccessControlEnumerableUpgradeable,\r\n  IAllowlist\r\n{\r\n  /// @dev Role based access control roles\r\n  bytes32 public constant ALLOWLIST_ADMIN = keccak256(\"ALLOWLIST_ADMIN\");\r\n  bytes32 public constant ALLOWLIST_SETTER = keccak256(\"ALLOWLIST_SETTER\");\r\n\r\n  /// @dev {<EOA> : {<term index> : <is verified>}};\r\n  mapping(address => mapping(uint256 => bool)) public verifications;\r\n\r\n  string[] public terms;\r\n  uint256 public currentTermIndex = 0;\r\n  uint256[] public validIndexes;\r\n\r\n  /// @custom:oz-upgrades-unsafe-allow constructor\r\n  constructor() {\r\n    _disableInitializers();\r\n  }\r\n\r\n  function initialize(address admin, address setter) public initializer {\r\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\r\n    _grantRole(ALLOWLIST_ADMIN, admin);\r\n    _grantRole(ALLOWLIST_SETTER, setter);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets a list term indexes that are valid for a user to be on the\r\n   *         allowlist\r\n   */\r\n  function getValidTermIndexes()\r\n    external\r\n    view\r\n    override\r\n    returns (uint256[] memory)\r\n  {\r\n    return validIndexes;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the current terms string associated with the\r\n   *         `currentTermIndex`\r\n   */\r\n  function getCurrentTerm() external view override returns (string memory) {\r\n    return terms[currentTermIndex];\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a term to the list of possible terms\r\n   *\r\n   * @param term Term to add\r\n   *\r\n   * @dev This function sets the current term index as the added term\r\n   * @dev The added term is not valid until it's added to validIndexes\r\n   */\r\n  function addTerm(\r\n    string calldata term\r\n  ) external override onlyRole(ALLOWLIST_ADMIN) {\r\n    terms.push(term);\r\n    setCurrentTermIndex(terms.length - 1);\r\n    emit TermAdded(keccak256(bytes(term)), terms.length - 1);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the current term index\r\n   *\r\n   * @param _currentTermIndex New current term index\r\n   *\r\n   * @dev The current term index is not a valid term until it's added to\r\n   *      validIndexes\r\n   * @dev This function will revert if the `_currentTermIndex` out of bounds\r\n   *      of the terms array\r\n   */\r\n  function setCurrentTermIndex(\r\n    uint256 _currentTermIndex\r\n  ) public override onlyRole(ALLOWLIST_ADMIN) {\r\n    if (_currentTermIndex >= terms.length) {\r\n      revert InvalidTermIndex();\r\n    }\r\n    uint256 oldIndex = currentTermIndex;\r\n    currentTermIndex = _currentTermIndex;\r\n    emit CurrentTermIndexSet(oldIndex, _currentTermIndex);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the list of valid term indexes\r\n   *\r\n   * @param _validIndexes List of new valid term indexes\r\n   *\r\n   * @dev Once the validIndexes are set, any user who has been verified to sign\r\n   *      a particular term will pass the `isAllowed` check\r\n   */\r\n  function setValidTermIndexes(\r\n    uint256[] calldata _validIndexes\r\n  ) external override onlyRole(ALLOWLIST_ADMIN) {\r\n    for (uint256 i; i < _validIndexes.length; ++i) {\r\n      if (_validIndexes[i] >= terms.length) {\r\n        revert InvalidTermIndex();\r\n      }\r\n    }\r\n    uint256[] memory oldIndexes = validIndexes;\r\n    validIndexes = _validIndexes;\r\n    emit ValidTermIndexesSet(oldIndexes, _validIndexes);\r\n  }\r\n\r\n  /**\r\n   * @notice Function that checks whether a user passes the allowlist check\r\n   *\r\n   * @param account Address of the account to check\r\n   *\r\n   * @dev Contracts are always allowed. Any entity that has signed a valid term\r\n   *      or added themselves to the allowslit for a valid term will pass the\r\n   *      check\r\n   */\r\n  function isAllowed(address account) external view override returns (bool) {\r\n    // Contracts are always allowed\r\n    if (AddressUpgradeable.isContract(account)) {\r\n      return true;\r\n    }\r\n\r\n    uint256 validIndexesLength = validIndexes.length;\r\n    for (uint256 i; i < validIndexesLength; ++i) {\r\n      if (verifications[account][validIndexes[i]]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @notice Function that allows a user to add themselves to the allowlist\r\n   *         for a given `termIndex`\r\n   *\r\n   * @param termIndex Term index for which the user is adding themselves to the\r\n   *                  allowlist\r\n   */\r\n  function addSelfToAllowlist(uint256 termIndex) external override {\r\n    if (verifications[msg.sender][termIndex]) {\r\n      revert AlreadyVerified();\r\n    }\r\n    _setAccountStatus(msg.sender, termIndex, true);\r\n    emit AccountAddedSelf(msg.sender, termIndex);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set an accounts status for a given term index\r\n   *\r\n   * @param account   Address of the account to set the status for\r\n   * @param termIndex Term index for which to update status for\r\n   * @param status    New status of the account\r\n   *\r\n   * @dev If a user's status has been set to false, a user can then set their\r\n   *      status back to true. This behavior is known. The allowlist should be\r\n   *      used in conjunction with a blocklist\r\n   */\r\n  function setAccountStatus(\r\n    address account,\r\n    uint256 termIndex,\r\n    bool status\r\n  ) external override onlyRole(ALLOWLIST_SETTER) {\r\n    _setAccountStatus(account, termIndex, status);\r\n    emit AccountStatusSetByAdmin(account, termIndex, status);\r\n  }\r\n\r\n  /**\r\n   * @notice Function that allows anyone to add a user to the allowlist with a\r\n   *         given off-chain signature\r\n   *\r\n   * @param termIndex Term index for which the user is adding themselves to the\r\n   *                  allowlist\r\n   * @param account   Address of the account to add to the allowlist\r\n   * @param v         v component of the signature\r\n   * @param r         r component of the signature\r\n   * @param s         s component of the signature\r\n   */\r\n  function addAccountToAllowlist(\r\n    uint256 termIndex,\r\n    address account,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    if (verifications[account][termIndex]) {\r\n      revert AlreadyVerified();\r\n    }\r\n\r\n    if (v != 27 && v != 28) {\r\n      revert InvalidVSignature();\r\n    }\r\n\r\n    bytes32 hashedMessage = ECDSA.toEthSignedMessageHash(\r\n      bytes(terms[termIndex])\r\n    );\r\n    address signer = ECDSA.recover(hashedMessage, v, r, s);\r\n\r\n    if (signer != account) {\r\n      revert InvalidSigner();\r\n    }\r\n    _setAccountStatus(account, termIndex, true);\r\n    emit AccountAddedFromSignature(account, termIndex, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set the status of an account for a given term\r\n   *\r\n   * @param account   Address of the account to set the status for\r\n   * @param termIndex Term index for which to update status for\r\n   * @param status    New status of the account\r\n   */\r\n  function _setAccountStatus(\r\n    address account,\r\n    uint256 termIndex,\r\n    bool status\r\n  ) internal {\r\n    if (termIndex >= terms.length) {\r\n      revert InvalidTermIndex();\r\n    }\r\n    verifications[account][termIndex] = status;\r\n    emit AccountStatusSet(account, termIndex, status);\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Strings.sol\";\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV // Deprecated in v4.8\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n    }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return \"0x00\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(uint256 value, uint256 length)\r\n    internal\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = \"0\";\r\n    buffer[1] = \"x\";\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, \"Strings: hex length insufficient\");\r\n    return string(buffer);\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721PresetMinterPauserAutoIdUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721EnumerableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721BurnableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721PausableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/CounterUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev {ERC721} token, including:\r\n *\r\n *  - ability for holders to burn (destroy) their tokens\r\n *  - a minter role that allows for token minting (creation)\r\n *  - a pauser role that allows to stop all token transfers\r\n *  - token ID and URI autogeneration\r\n *\r\n * This contract uses {AccessControl} to lock permissioned functions using the\r\n * different roles - head to its documentation for details.\r\n *\r\n * The account that deploys the contract will be granted the minter and pauser\r\n * roles, as well as the default admin role, which will let it grant both minter\r\n * and pauser roles to other accounts.\r\n *\r\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\r\n */\r\ncontract ERC721PresetMinterPauserAutoIdUpgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  AccessControlEnumerableUpgradeable,\r\n  ERC721EnumerableUpgradeable,\r\n  ERC721BurnableUpgradeable,\r\n  ERC721PausableUpgradeable\r\n{\r\n  function initialize(\r\n    string memory name,\r\n    string memory symbol,\r\n    string memory baseTokenURI\r\n  ) public virtual initializer {\r\n    __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);\r\n  }\r\n\r\n  using CountersUpgradeable for CountersUpgradeable.Counter;\r\n\r\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n\r\n  CountersUpgradeable.Counter private _tokenIdTracker;\r\n\r\n  string private _baseTokenURI;\r\n\r\n  /**\r\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\r\n   * account that deploys the contract.\r\n   *\r\n   * Token URIs will be autogenerated based on `baseURI` and their token IDs.\r\n   * See {ERC721-tokenURI}.\r\n   */\r\n  function __ERC721PresetMinterPauserAutoId_init(\r\n    string memory name,\r\n    string memory symbol,\r\n    string memory baseTokenURI\r\n  ) internal onlyInitializing {\r\n    __ERC721_init_unchained(name, symbol);\r\n    __Pausable_init_unchained();\r\n    __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\r\n  }\r\n\r\n  function __ERC721PresetMinterPauserAutoId_init_unchained(\r\n    string memory,\r\n    string memory,\r\n    string memory baseTokenURI\r\n  ) internal onlyInitializing {\r\n    _baseTokenURI = baseTokenURI;\r\n\r\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n\r\n    _setupRole(MINTER_ROLE, _msgSender());\r\n    _setupRole(PAUSER_ROLE, _msgSender());\r\n  }\r\n\r\n  function _baseURI() internal view virtual override returns (string memory) {\r\n    return _baseTokenURI;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a new token for `to`. Its token ID will be automatically\r\n   * assigned (and available on the emitted {IERC721-Transfer} event), and the token\r\n   * URI autogenerated based on the base URI passed at construction.\r\n   *\r\n   * See {ERC721-_mint}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `MINTER_ROLE`.\r\n   */\r\n  function mint(address to) public virtual {\r\n    require(\r\n      hasRole(MINTER_ROLE, _msgSender()),\r\n      \"ERC721PresetMinterPauserAutoId: must have minter role to mint\"\r\n    );\r\n\r\n    // We cannot just use balanceOf to create the new tokenId because tokens\r\n    // can be burned (destroyed), so we need a separate counter.\r\n    _mint(to, _tokenIdTracker.current());\r\n    _tokenIdTracker.increment();\r\n  }\r\n\r\n  /**\r\n   * @dev Pauses all token transfers.\r\n   *\r\n   * See {ERC721Pausable} and {Pausable-_pause}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `PAUSER_ROLE`.\r\n   */\r\n  function pause() public virtual {\r\n    require(\r\n      hasRole(PAUSER_ROLE, _msgSender()),\r\n      \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\"\r\n    );\r\n    _pause();\r\n  }\r\n\r\n  /**\r\n   * @dev Unpauses all token transfers.\r\n   *\r\n   * See {ERC721Pausable} and {Pausable-_unpause}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have the `PAUSER_ROLE`.\r\n   */\r\n  function unpause() public virtual {\r\n    require(\r\n      hasRole(PAUSER_ROLE, _msgSender()),\r\n      \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\"\r\n    );\r\n    _unpause();\r\n  }\r\n\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  )\r\n    internal\r\n    virtual\r\n    override(\r\n      ERC721Upgradeable,\r\n      ERC721EnumerableUpgradeable,\r\n      ERC721PausableUpgradeable\r\n    )\r\n  {\r\n    super._beforeTokenTransfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override(\r\n      AccessControlEnumerableUpgradeable,\r\n      ERC721Upgradeable,\r\n      ERC721EnumerableUpgradeable\r\n    )\r\n    returns (bool)\r\n  {\r\n    return super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[48] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ERC165Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721Upgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  ERC165Upgradeable,\r\n  IERC721Upgradeable,\r\n  IERC721MetadataUpgradeable\r\n{\r\n  using AddressUpgradeable for address;\r\n  using StringsUpgradeable for uint256;\r\n\r\n  // Token name\r\n  string private _name;\r\n\r\n  // Token symbol\r\n  string private _symbol;\r\n\r\n  // Mapping from token ID to owner address\r\n  mapping(uint256 => address) private _owners;\r\n\r\n  // Mapping owner address to token count\r\n  mapping(address => uint256) private _balances;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping(uint256 => address) private _tokenApprovals;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n  /**\r\n   * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n   */\r\n  function __ERC721_init(string memory name_, string memory symbol_)\r\n    internal\r\n    onlyInitializing\r\n  {\r\n    __ERC721_init_unchained(name_, symbol_);\r\n  }\r\n\r\n  function __ERC721_init_unchained(string memory name_, string memory symbol_)\r\n    internal\r\n    onlyInitializing\r\n  {\r\n    _name = name_;\r\n    _symbol = symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override(ERC165Upgradeable, IERC165Upgradeable)\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IERC721Upgradeable).interfaceId ||\r\n      interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-balanceOf}.\r\n   */\r\n  function balanceOf(address owner)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-ownerOf}.\r\n   */\r\n  function ownerOf(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (address)\r\n  {\r\n    address owner = _owners[tokenId];\r\n    require(owner != address(0), \"ERC721: invalid token ID\");\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Metadata-name}.\r\n   */\r\n  function name() public view virtual override returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Metadata-symbol}.\r\n   */\r\n  function symbol() public view virtual override returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Metadata-tokenURI}.\r\n   */\r\n  function tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (string memory)\r\n  {\r\n    _requireMinted(tokenId);\r\n\r\n    string memory baseURI = _baseURI();\r\n    return\r\n      bytes(baseURI).length > 0\r\n        ? string(abi.encodePacked(baseURI, tokenId.toString()))\r\n        : \"\";\r\n  }\r\n\r\n  /**\r\n   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n   * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n   * by default, can be overridden in child contracts.\r\n   */\r\n  function _baseURI() internal view virtual returns (string memory) {\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-approve}.\r\n   */\r\n  function approve(address to, uint256 tokenId) public virtual override {\r\n    address owner = ERC721Upgradeable.ownerOf(tokenId);\r\n    require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n    require(\r\n      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n      \"ERC721: approve caller is not token owner nor approved for all\"\r\n    );\r\n\r\n    _approve(to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-getApproved}.\r\n   */\r\n  function getApproved(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (address)\r\n  {\r\n    _requireMinted(tokenId);\r\n\r\n    return _tokenApprovals[tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-setApprovalForAll}.\r\n   */\r\n  function setApprovalForAll(address operator, bool approved)\r\n    public\r\n    virtual\r\n    override\r\n  {\r\n    _setApprovalForAll(_msgSender(), operator, approved);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-isApprovedForAll}.\r\n   */\r\n  function isApprovedForAll(address owner, address operator)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return _operatorApprovals[owner][operator];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-transferFrom}.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) public virtual override {\r\n    //solhint-disable-next-line max-line-length\r\n    require(\r\n      _isApprovedOrOwner(_msgSender(), tokenId),\r\n      \"ERC721: caller is not token owner nor approved\"\r\n    );\r\n\r\n    _transfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-safeTransferFrom}.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) public virtual override {\r\n    safeTransferFrom(from, to, tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-safeTransferFrom}.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory data\r\n  ) public virtual override {\r\n    require(\r\n      _isApprovedOrOwner(_msgSender(), tokenId),\r\n      \"ERC721: caller is not token owner nor approved\"\r\n    );\r\n    _safeTransfer(from, to, tokenId, data);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * `data` is additional data, it has no specified format and it is sent in call to `to`.\r\n   *\r\n   * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n   * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _safeTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory data\r\n  ) internal virtual {\r\n    _transfer(from, to, tokenId);\r\n    require(\r\n      _checkOnERC721Received(from, to, tokenId, data),\r\n      \"ERC721: transfer to non ERC721Receiver implementer\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether `tokenId` exists.\r\n   *\r\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n   *\r\n   * Tokens start existing when they are minted (`_mint`),\r\n   * and stop existing when they are burned (`_burn`).\r\n   */\r\n  function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n    return _owners[tokenId] != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n    internal\r\n    view\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    address owner = ERC721Upgradeable.ownerOf(tokenId);\r\n    return (spender == owner ||\r\n      isApprovedForAll(owner, spender) ||\r\n      getApproved(tokenId) == spender);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely mints `tokenId` and transfers it to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must not exist.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _safeMint(address to, uint256 tokenId) internal virtual {\r\n    _safeMint(to, tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n   * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n   */\r\n  function _safeMint(\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory data\r\n  ) internal virtual {\r\n    _mint(to, tokenId);\r\n    require(\r\n      _checkOnERC721Received(address(0), to, tokenId, data),\r\n      \"ERC721: transfer to non ERC721Receiver implementer\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Mints `tokenId` and transfers it to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must not exist.\r\n   * - `to` cannot be the zero address.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _mint(address to, uint256 tokenId) internal virtual {\r\n    require(to != address(0), \"ERC721: mint to the zero address\");\r\n    require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n    _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n    _balances[to] += 1;\r\n    _owners[tokenId] = to;\r\n\r\n    emit Transfer(address(0), to, tokenId);\r\n\r\n    _afterTokenTransfer(address(0), to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `tokenId`.\r\n   * The approval is cleared when the token is burned.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _burn(uint256 tokenId) internal virtual {\r\n    address owner = ERC721Upgradeable.ownerOf(tokenId);\r\n\r\n    _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n    // Clear approvals\r\n    _approve(address(0), tokenId);\r\n\r\n    _balances[owner] -= 1;\r\n    delete _owners[tokenId];\r\n\r\n    emit Transfer(owner, address(0), tokenId);\r\n\r\n    _afterTokenTransfer(owner, address(0), tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` from `from` to `to`.\r\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) internal virtual {\r\n    require(\r\n      ERC721Upgradeable.ownerOf(tokenId) == from,\r\n      \"ERC721: transfer from incorrect owner\"\r\n    );\r\n    require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n    _beforeTokenTransfer(from, to, tokenId);\r\n\r\n    // Clear approvals from the previous owner\r\n    _approve(address(0), tokenId);\r\n\r\n    _balances[from] -= 1;\r\n    _balances[to] += 1;\r\n    _owners[tokenId] = to;\r\n\r\n    emit Transfer(from, to, tokenId);\r\n\r\n    _afterTokenTransfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve `to` to operate on `tokenId`\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function _approve(address to, uint256 tokenId) internal virtual {\r\n    _tokenApprovals[tokenId] = to;\r\n    emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve `operator` to operate on all of `owner` tokens\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function _setApprovalForAll(\r\n    address owner,\r\n    address operator,\r\n    bool approved\r\n  ) internal virtual {\r\n    require(owner != operator, \"ERC721: approve to caller\");\r\n    _operatorApprovals[owner][operator] = approved;\r\n    emit ApprovalForAll(owner, operator, approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the `tokenId` has not been minted yet.\r\n   */\r\n  function _requireMinted(uint256 tokenId) internal view virtual {\r\n    require(_exists(tokenId), \"ERC721: invalid token ID\");\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n   * The call is not executed if the target address is not a contract.\r\n   *\r\n   * @param from address representing the previous owner of the given token ID\r\n   * @param to target address that will receive the tokens\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   * @param data bytes optional data to send along with the call\r\n   * @return bool whether the call correctly returned the expected magic value\r\n   */\r\n  function _checkOnERC721Received(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory data\r\n  ) private returns (bool) {\r\n    if (to.isContract()) {\r\n      try\r\n        IERC721ReceiverUpgradeable(to).onERC721Received(\r\n          _msgSender(),\r\n          from,\r\n          tokenId,\r\n          data\r\n        )\r\n      returns (bytes4 retval) {\r\n        return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\r\n      } catch (bytes memory reason) {\r\n        if (reason.length == 0) {\r\n          revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n        } else {\r\n          /// @solidity memory-safe-assembly\r\n          assembly {\r\n            revert(add(32, reason), mload(reason))\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any token transfer. This includes minting\r\n   * and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n   * transferred to `to`.\r\n   * - When `from` is zero, `tokenId` will be minted for `to`.\r\n   * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) internal virtual {}\r\n\r\n  /**\r\n   * @dev Hook that is called after any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _afterTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) internal virtual {}\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[44] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\r\n * enumerability of all the token ids in the contract as well as all token ids owned by each\r\n * account.\r\n */\r\nabstract contract ERC721EnumerableUpgradeable is\r\n  Initializable,\r\n  ERC721Upgradeable,\r\n  IERC721EnumerableUpgradeable\r\n{\r\n  function __ERC721Enumerable_init() internal onlyInitializing {}\r\n\r\n  function __ERC721Enumerable_init_unchained() internal onlyInitializing {}\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n  // Array with all token ids, used for enumeration\r\n  uint256[] private _allTokens;\r\n\r\n  // Mapping from token id to position in the allTokens array\r\n  mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override(IERC165Upgradeable, ERC721Upgradeable)\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IERC721EnumerableUpgradeable).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n   */\r\n  function tokenOfOwnerByIndex(address owner, uint256 index)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    require(\r\n      index < ERC721Upgradeable.balanceOf(owner),\r\n      \"ERC721Enumerable: owner index out of bounds\"\r\n    );\r\n    return _ownedTokens[owner][index];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Enumerable-totalSupply}.\r\n   */\r\n  function totalSupply() public view virtual override returns (uint256) {\r\n    return _allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Enumerable-tokenByIndex}.\r\n   */\r\n  function tokenByIndex(uint256 index)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    require(\r\n      index < ERC721EnumerableUpgradeable.totalSupply(),\r\n      \"ERC721Enumerable: global index out of bounds\"\r\n    );\r\n    return _allTokens[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any token transfer. This includes minting\r\n   * and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n   * transferred to `to`.\r\n   * - When `from` is zero, `tokenId` will be minted for `to`.\r\n   * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) internal virtual override {\r\n    super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n    if (from == address(0)) {\r\n      _addTokenToAllTokensEnumeration(tokenId);\r\n    } else if (from != to) {\r\n      _removeTokenFromOwnerEnumeration(from, tokenId);\r\n    }\r\n    if (to == address(0)) {\r\n      _removeTokenFromAllTokensEnumeration(tokenId);\r\n    } else if (to != from) {\r\n      _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n   * @param to address representing the new owner of the given token ID\r\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n    uint256 length = ERC721Upgradeable.balanceOf(to);\r\n    _ownedTokens[to][length] = tokenId;\r\n    _ownedTokensIndex[tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Private function to add a token to this extension's token tracking data structures.\r\n   * @param tokenId uint256 ID of the token to be added to the tokens list\r\n   */\r\n  function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n    _allTokensIndex[tokenId] = _allTokens.length;\r\n    _allTokens.push(tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n   * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n   * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n   * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n   * @param from address representing the previous owner of the given token ID\r\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\r\n    private\r\n  {\r\n    // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n    // then delete the last slot (swap and pop).\r\n\r\n    uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\r\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n    // When the token to delete is the last token, the swap operation is unnecessary\r\n    if (tokenIndex != lastTokenIndex) {\r\n      uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n      _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n      _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n    }\r\n\r\n    // This also deletes the contents at the last position of the array\r\n    delete _ownedTokensIndex[tokenId];\r\n    delete _ownedTokens[from][lastTokenIndex];\r\n  }\r\n\r\n  /**\r\n   * @dev Private function to remove a token from this extension's token tracking data structures.\r\n   * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n   * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n   */\r\n  function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n    // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n    // then delete the last slot (swap and pop).\r\n\r\n    uint256 lastTokenIndex = _allTokens.length - 1;\r\n    uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n    // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n    // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n    // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n    _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n    _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n    // This also deletes the contents at the last position of the array\r\n    delete _allTokensIndex[tokenId];\r\n    _allTokens.pop();\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[46] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @title ERC721 Burnable Token\r\n * @dev ERC721 Token that can be burned (destroyed).\r\n */\r\nabstract contract ERC721BurnableUpgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  ERC721Upgradeable\r\n{\r\n  function __ERC721Burnable_init() internal onlyInitializing {}\r\n\r\n  function __ERC721Burnable_init_unchained() internal onlyInitializing {}\r\n\r\n  /**\r\n   * @dev Burns `tokenId`. See {ERC721-_burn}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own `tokenId` or be an approved operator.\r\n   */\r\n  function burn(uint256 tokenId) public virtual {\r\n    //solhint-disable-next-line max-line-length\r\n    require(\r\n      _isApprovedOrOwner(_msgSender(), tokenId),\r\n      \"ERC721: caller is not token owner nor approved\"\r\n    );\r\n    _burn(tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\n/**\r\n * @dev ERC721 token with pausable token transfers, minting and burning.\r\n *\r\n * Useful for scenarios such as preventing trades until the end of an evaluation\r\n * period, or having an emergency switch for freezing all token transfers in the\r\n * event of a large bug.\r\n */\r\nabstract contract ERC721PausableUpgradeable is\r\n  Initializable,\r\n  ERC721Upgradeable,\r\n  PausableUpgradeable\r\n{\r\n  function __ERC721Pausable_init() internal onlyInitializing {\r\n    __Pausable_init_unchained();\r\n  }\r\n\r\n  function __ERC721Pausable_init_unchained() internal onlyInitializing {}\r\n\r\n  /**\r\n   * @dev See {ERC721-_beforeTokenTransfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the contract must not be paused.\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) internal virtual override {\r\n    super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n    require(!paused(), \"ERC721Pausable: token transfer while paused\");\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/CounterUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary CountersUpgradeable {\r\n  struct Counter {\r\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n    uint256 _value; // default: 0\r\n  }\r\n\r\n  function current(Counter storage counter) internal view returns (uint256) {\r\n    return counter._value;\r\n  }\r\n\r\n  function increment(Counter storage counter) internal {\r\n    unchecked {\r\n      counter._value += 1;\r\n    }\r\n  }\r\n\r\n  function decrement(Counter storage counter) internal {\r\n    uint256 value = counter._value;\r\n    require(value > 0, \"Counter: decrement overflow\");\r\n    unchecked {\r\n      counter._value = value - 1;\r\n    }\r\n  }\r\n\r\n  function reset(Counter storage counter) internal {\r\n    counter._value = 0;\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/IERC165Upgradeable.sol\";\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721Upgradeable is IERC165Upgradeable {\r\n  /**\r\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n   */\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n   */\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed approved,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed owner,\r\n    address indexed operator,\r\n    bool approved\r\n  );\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(uint256 tokenId)\r\n    external\r\n    view\r\n    returns (address operator);\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(address owner, address operator)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721ReceiverUpgradeable {\r\n  /**\r\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n   * by `operator` from `from`, this function is called.\r\n   *\r\n   * It must return its Solidity selector to confirm the token transfer.\r\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n   *\r\n   * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n   */\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external returns (bytes4);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\r\n  /**\r\n   * @dev Returns the token collection name.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the token collection symbol.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n   */\r\n  function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\r\n  /**\r\n   * @dev Returns the total amount of tokens stored by the contract.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n   */\r\n  function tokenOfOwnerByIndex(address owner, uint256 index)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n   * Use along with {totalSupply} to enumerate all tokens.\r\n   */\r\n  function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/usdy/blocklist/BlocklistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IBlocklist.sol\";\r\nimport \"contracts/interfaces/IBlocklistClient.sol\";\r\n\r\n/**\r\n * @title BlocklistClient\r\n * @author Ondo Finance\r\n * @notice This abstract contract manages state for blocklist clients\r\n */\r\nabstract contract BlocklistClient is IBlocklistClient {\r\n  // blocklist address\r\n  IBlocklist public override blocklist;\r\n\r\n  /**\r\n   * @notice Constructor\r\n   *\r\n   * @param _blocklist Address of the blocklist contract\r\n   */\r\n  constructor(address _blocklist) {\r\n    _setBlocklist(_blocklist);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the blocklist address for this client\r\n   *\r\n   * @param _blocklist The new blocklist address\r\n   */\r\n  function _setBlocklist(address _blocklist) internal {\r\n    if (_blocklist == address(0)) {\r\n      revert BlocklistZeroAddress();\r\n    }\r\n    address oldBlocklist = address(blocklist);\r\n    blocklist = IBlocklist(_blocklist);\r\n    emit BlocklistSet(oldBlocklist, _blocklist);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether an address has been blocked\r\n   *\r\n   * @param account The account to check\r\n   */\r\n  function _isBlocked(address account) internal view returns (bool) {\r\n    return blocklist.isBlocked(account);\r\n  }\r\n}\r\n"
    },
    "contracts/usdy/blocklist/Blocklist.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\nimport \"contracts/external/openzeppelin/contracts/access/Ownable2Step.sol\";\r\nimport \"contracts/interfaces/IBlocklist.sol\";\r\n\r\n/**\r\n * @title Blocklist\r\n * @author Ondo Finance\r\n * @notice This contract manages the blocklist status for accounts.\r\n */\r\ncontract Blocklist is Ownable2Step, IBlocklist {\r\n  constructor() {}\r\n\r\n  // {<address> => is account blocked}\r\n  mapping(address => bool) private blockedAddresses;\r\n\r\n  /**\r\n   * @notice Returns name of contract\r\n   */\r\n  function name() external pure returns (string memory) {\r\n    return \"Ondo Finance Blocklist Oracle\";\r\n  }\r\n\r\n  /**\r\n   * @notice Function to add a list of accounts to the blocklist\r\n   *\r\n   * @param accounts Array of addresses to block\r\n   */\r\n  function addToBlocklist(address[] calldata accounts) external onlyOwner {\r\n    for (uint256 i; i < accounts.length; ++i) {\r\n      blockedAddresses[accounts[i]] = true;\r\n    }\r\n    emit BlockedAddressesAdded(accounts);\r\n  }\r\n\r\n  /**\r\n   * @notice Function to remove a list of accounts from the blocklist\r\n   *\r\n   * @param accounts Array of addresses to unblock\r\n   */\r\n  function removeFromBlocklist(address[] calldata accounts) external onlyOwner {\r\n    for (uint256 i; i < accounts.length; ++i) {\r\n      blockedAddresses[accounts[i]] = false;\r\n    }\r\n    emit BlockedAddressesRemoved(accounts);\r\n  }\r\n\r\n  /**\r\n   * @notice Function to check if an account is blocked\r\n   *\r\n   * @param addr Address to check\r\n   *\r\n   * @return True if account is blocked, false otherwise\r\n   */\r\n  function isBlocked(address addr) external view returns (bool) {\r\n    return blockedAddresses[addr];\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2Step is Ownable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() public virtual {\r\n        address sender = _msgSender();\r\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\r\n        _transferOwnership(sender);\r\n    }\r\n}"
    },
    "contracts/external/openzeppelin/contracts/token/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transfer.selector, to, value)\r\n    );\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Deprecated. This function has issues similar to the ones found in\r\n   * {IERC20-approve}, and its usage is discouraged.\r\n   *\r\n   * Whenever possible, use {safeIncreaseAllowance} and\r\n   * {safeDecreaseAllowance} instead.\r\n   */\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n    );\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.approve.selector, spender, value)\r\n    );\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n    );\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    unchecked {\r\n      uint256 oldAllowance = token.allowance(address(this), spender);\r\n      require(\r\n        oldAllowance >= value,\r\n        \"SafeERC20: decreased allowance below zero\"\r\n      );\r\n      uint256 newAllowance = oldAllowance - value;\r\n      _callOptionalReturn(\r\n        token,\r\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n   * @param token The token targeted by the call.\r\n   * @param data The call data (encoded using abi.encode or one of its variants).\r\n   */\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n    // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n    bytes memory returndata =\r\n      address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      require(\r\n        abi.decode(returndata, (bool)),\r\n        \"SafeERC20: ERC20 operation did not succeed\"\r\n      );\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `to`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `from` to `to` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "contracts/RWAHub.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IPricerReader.sol\";\r\nimport \"contracts/interfaces/IRWALike.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/token/SafeERC20.sol\";\r\nimport \"contracts/interfaces/IRWAHub.sol\";\r\n\r\n// Additional Dependencies\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nabstract contract RWAHub is IRWAHub, ReentrancyGuard, AccessControlEnumerable {\r\n  using SafeERC20 for IERC20;\r\n  // RWA Token contract\r\n  IRWALike public immutable rwa;\r\n  // Pointer to Pricer\r\n  IPricerReader public pricer;\r\n  // Address to receive deposits\r\n  address public constant assetRecipient =\r\n    0xbDa73A0F13958ee444e0782E1768aB4B76EdaE28; // USDY - CB Deposit Address\r\n  // Address to send redemptions\r\n  address public assetSender;\r\n  // Address fee recipient\r\n  address public feeRecipient;\r\n  // Mapping from deposit Id -> Depositor\r\n  mapping(bytes32 => Depositor) public depositIdToDepositor;\r\n  // Mapping from redemptionId -> Redeemer\r\n  mapping(bytes32 => Redeemer) public redemptionIdToRedeemer;\r\n\r\n  /// @dev Mint/Redeem Parameters\r\n  // Minimum amount that must be deposited to mint the RWA token\r\n  // Denoted in decimals of `collateral`\r\n  uint256 public minimumDepositAmount;\r\n\r\n  // Minimum amount that must be redeemed for a withdraw request\r\n  uint256 public minimumRedemptionAmount;\r\n\r\n  // Minting fee specified in basis points\r\n  uint256 public mintFee = 0;\r\n\r\n  // Redemption fee specified in basis points\r\n  uint256 public redemptionFee = 0;\r\n\r\n  // The asset accepted by the RWAHub\r\n  IERC20 public immutable collateral;\r\n\r\n  // Decimal multiplier representing the difference between `rwa` decimals\r\n  // In `collateral` token decimals\r\n  uint256 public immutable decimalsMultiplier;\r\n\r\n  // Deposit counter to map subscription requests to\r\n  uint256 public subscriptionRequestCounter = 1;\r\n\r\n  // Redemption Id to map from\r\n  uint256 public redemptionRequestCounter = 1;\r\n\r\n  // Helper constant that allows us to specify basis points in calculations\r\n  uint256 public constant BPS_DENOMINATOR = 10_000;\r\n\r\n  // Pause variables\r\n  bool public redemptionPaused;\r\n  bool public subscriptionPaused;\r\n\r\n  /// @dev Role based access control roles\r\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\r\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\r\n  bytes32 public constant PRICE_ID_SETTER_ROLE =\r\n    keccak256(\"PRICE_ID_SETTER_ROLE\");\r\n  bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\r\n\r\n  /// @notice constructor\r\n  constructor(\r\n    address _collateral,\r\n    address _rwa,\r\n    address managerAdmin,\r\n    address pauser,\r\n    address _assetSender,\r\n    address _feeRecipient,\r\n    uint256 _minimumDepositAmount,\r\n    uint256 _minimumRedemptionAmount\r\n  ) {\r\n    if (_collateral == address(0)) {\r\n      revert CollateralCannotBeZero();\r\n    }\r\n    if (_rwa == address(0)) {\r\n      revert RWACannotBeZero();\r\n    }\r\n    if (_assetSender == address(0)) {\r\n      revert AssetSenderCannotBeZero();\r\n    }\r\n    if (_feeRecipient == address(0)) {\r\n      revert FeeRecipientCannotBeZero();\r\n    }\r\n\r\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\r\n    _grantRole(MANAGER_ADMIN, managerAdmin);\r\n    _grantRole(PAUSER_ADMIN, pauser);\r\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\r\n    _setRoleAdmin(PRICE_ID_SETTER_ROLE, MANAGER_ADMIN);\r\n    _setRoleAdmin(RELAYER_ROLE, MANAGER_ADMIN);\r\n\r\n    collateral = IERC20(_collateral);\r\n    rwa = IRWALike(_rwa);\r\n    feeRecipient = _feeRecipient;\r\n    assetSender = _assetSender;\r\n    minimumDepositAmount = _minimumDepositAmount;\r\n    minimumRedemptionAmount = _minimumRedemptionAmount;\r\n\r\n    decimalsMultiplier =\r\n      10 **\r\n        (IERC20Metadata(_rwa).decimals() -\r\n          IERC20Metadata(_collateral).decimals());\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                  Subscription/Redemption Functions\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Function used by users to request subscription to the fund\r\n   *\r\n   * @param amount The amount of collateral one wished to deposit\r\n   */\r\n  function requestSubscription(\r\n    uint256 amount\r\n  )\r\n    external\r\n    virtual\r\n    nonReentrant\r\n    ifNotPaused(subscriptionPaused)\r\n  {\r\n    if (amount < minimumDepositAmount) {\r\n      revert DepositTooSmall();\r\n    }\r\n\r\n    uint256 feesInCollateral = _getMintFees(amount);\r\n    uint256 depositAmountAfterFee = amount - feesInCollateral;\r\n\r\n    // Link the depositor to their deposit ID\r\n    bytes32 depositId = bytes32(subscriptionRequestCounter++);\r\n    depositIdToDepositor[depositId] = Depositor(\r\n      msg.sender,\r\n      depositAmountAfterFee,\r\n      0\r\n    );\r\n\r\n    if (feesInCollateral > 0) {\r\n      collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\r\n    }\r\n\r\n    collateral.safeTransferFrom(\r\n      msg.sender,\r\n      assetRecipient,\r\n      depositAmountAfterFee\r\n    );\r\n\r\n    emit MintRequested(\r\n      msg.sender,\r\n      depositId,\r\n      amount,\r\n      depositAmountAfterFee,\r\n      feesInCollateral\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Function used to claim tokens corresponding to a deposit request\r\n   *\r\n   * @param depositIds An array containing the deposit Ids one wishes to claim\r\n   *\r\n   * @dev Implicitly does all transfer checks present in underlying `rwa`\r\n   * @dev The priceId corresponding to a given depositId must be set prior to\r\n   *      claiming a mint\r\n   */\r\n  function claimMint(\r\n    bytes32[] calldata depositIds\r\n  ) external virtual nonReentrant ifNotPaused(subscriptionPaused) {\r\n    uint256 depositsSize = depositIds.length;\r\n    for (uint256 i = 0; i < depositsSize; ++i) {\r\n      _claimMint(depositIds[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal claim mint helper\r\n   *\r\n   * @dev This function can be overriden to implement custom claiming logic\r\n   */\r\n  function _claimMint(bytes32 depositId) internal virtual {\r\n    Depositor memory depositor = depositIdToDepositor[depositId];\r\n    // Revert if priceId is not set\r\n    if (depositor.priceId == 0) {\r\n      revert PriceIdNotSet();\r\n    }\r\n\r\n    uint256 price = pricer.getPrice(depositor.priceId);\r\n    uint256 rwaOwed = _getMintAmountForPrice(\r\n      depositor.amountDepositedMinusFees,\r\n      price\r\n    );\r\n\r\n    delete depositIdToDepositor[depositId];\r\n    rwa.mint(depositor.user, rwaOwed);\r\n\r\n    emit MintCompleted(\r\n      depositor.user,\r\n      depositId,\r\n      rwaOwed,\r\n      depositor.amountDepositedMinusFees,\r\n      price,\r\n      depositor.priceId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Function used by users to request a redemption from the fund\r\n   *\r\n   * @param amount The amount (in units of `rwa`) that a user wishes to redeem\r\n   *               from the fund\r\n   */\r\n  function requestRedemption(\r\n    uint256 amount\r\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\r\n    if (amount < minimumRedemptionAmount) {\r\n      revert RedemptionTooSmall();\r\n    }\r\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\r\n    redemptionIdToRedeemer[redemptionId] = Redeemer(msg.sender, amount, 0);\r\n\r\n    rwa.burnFrom(msg.sender, amount);\r\n\r\n    emit RedemptionRequested(msg.sender, redemptionId, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Function to claim collateral corresponding to a redemption request\r\n   *\r\n   * @param redemptionIds an Array of redemption Id's which ought to fulfilled\r\n   *\r\n   * @dev Implicitly does all checks present in underlying `rwa`\r\n   * @dev The price Id corresponding to a redemptionId must be set prior to\r\n   *      claiming a redemption\r\n   */\r\n  function claimRedemption(\r\n    bytes32[] calldata redemptionIds\r\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\r\n    uint256 fees;\r\n    uint256 redemptionsSize = redemptionIds.length;\r\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\r\n      Redeemer memory member = redemptionIdToRedeemer[redemptionIds[i]];\r\n      //_checkRestrictions(member.user);\r\n      if (member.priceId == 0) {\r\n        // Then the price for this redemption has not been set\r\n        revert PriceIdNotSet();\r\n      }\r\n\r\n      // Calculate collateral due and fees\r\n      uint256 price = pricer.getPrice(member.priceId);\r\n      uint256 collateralDue = _getRedemptionAmountForRwa(\r\n        member.amountRwaTokenBurned,\r\n        price\r\n      );\r\n      uint256 fee = _getRedemptionFees(collateralDue);\r\n      uint256 collateralDuePostFees = collateralDue - fee;\r\n      fees += fee;\r\n\r\n      delete redemptionIdToRedeemer[redemptionIds[i]];\r\n\r\n      collateral.safeTransferFrom(\r\n        assetSender,\r\n        member.user,\r\n        collateralDuePostFees\r\n      );\r\n\r\n      emit RedemptionCompleted(\r\n        member.user,\r\n        redemptionIds[i],\r\n        member.amountRwaTokenBurned,\r\n        collateralDuePostFees,\r\n        price\r\n      );\r\n    }\r\n    if (fees > 0) {\r\n      collateral.safeTransferFrom(assetSender, feeRecipient, fees);\r\n    }\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                         Relayer Functions\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Adds a deposit proof to the contract\r\n   *\r\n   * @param txHash                The transaction hash of the deposit\r\n   * @param user                  The address of the user who made the deposit\r\n   * @param depositAmountAfterFee The amount of the deposit after fees\r\n   * @param feeAmount             The amount of the fees taken\r\n   * @param timestamp             The timestamp of the deposit\r\n   *\r\n   * @dev txHash is used as the depositId in storage\r\n   * @dev All amounts are in decimals of `collateral`\r\n   */\r\n  function addProof(\r\n    bytes32 txHash,\r\n    address user,\r\n    uint256 depositAmountAfterFee,\r\n    uint256 feeAmount,\r\n    uint256 timestamp\r\n  ) external override onlyRole(RELAYER_ROLE) {\r\n    if (depositIdToDepositor[txHash].user != address(0)) {\r\n      revert DepositProofAlreadyExists();\r\n    }\r\n    depositIdToDepositor[txHash] = Depositor(user, depositAmountAfterFee, 0);\r\n    emit DepositProofAdded(\r\n      txHash,\r\n      user,\r\n      depositAmountAfterFee,\r\n      feeAmount,\r\n      timestamp\r\n    );\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                           PriceId Setters\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Admin function to associate a depositId with a given Price Id\r\n   *\r\n   * @param depositIds an Array of deposit Ids to be associated\r\n   * @param priceIds   an Array of price Ids to be associated\r\n   *\r\n   * @dev Array size must match\r\n   */\r\n  function setPriceIdForDeposits(\r\n    bytes32[] calldata depositIds,\r\n    uint256[] calldata priceIds\r\n  ) external virtual onlyRole(PRICE_ID_SETTER_ROLE) {\r\n    uint256 depositsSize = depositIds.length;\r\n    if (depositsSize != priceIds.length) {\r\n      revert ArraySizeMismatch();\r\n    }\r\n    for (uint256 i = 0; i < depositsSize; ++i) {\r\n      if (depositIdToDepositor[depositIds[i]].user == address(0)) {\r\n        revert DepositorNull();\r\n      }\r\n      if (depositIdToDepositor[depositIds[i]].priceId != 0) {\r\n        revert PriceIdAlreadySet();\r\n      }\r\n      depositIdToDepositor[depositIds[i]].priceId = priceIds[i];\r\n      emit PriceIdSetForDeposit(depositIds[i], priceIds[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to associate redemptionId with a given priceId\r\n   *\r\n   * @param redemptionIds an Array of redemptionIds to associate\r\n   * @param priceIds  an Array of priceIds to associate\r\n   */\r\n  function setPriceIdForRedemptions(\r\n    bytes32[] calldata redemptionIds,\r\n    uint256[] calldata priceIds\r\n  ) external virtual onlyRole(PRICE_ID_SETTER_ROLE) {\r\n    uint256 redemptionsSize = redemptionIds.length;\r\n    if (redemptionsSize != priceIds.length) {\r\n      revert ArraySizeMismatch();\r\n    }\r\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\r\n      if (redemptionIdToRedeemer[redemptionIds[i]].priceId != 0) {\r\n        revert PriceIdAlreadySet();\r\n      }\r\n      redemptionIdToRedeemer[redemptionIds[i]].priceId = priceIds[i];\r\n      emit PriceIdSetForRedemption(redemptionIds[i], priceIds[i]);\r\n    }\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                           Admin Setters\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Admin function to overwrite entries in the depoitIdToDepositor\r\n   *         mapping\r\n   *\r\n   * @param depositIdToOverwrite  The depositId of the entry we wish to\r\n   *                              overwrite\r\n   * @param user                  The user for the new entry\r\n   * @param depositAmountAfterFee The deposit value for the new entry\r\n   * @param priceId               The priceId to be associated with the new\r\n   *                              entry\r\n   */\r\n  function overwriteDepositor(\r\n    bytes32 depositIdToOverwrite,\r\n    address user,\r\n    uint256 depositAmountAfterFee,\r\n    uint256 priceId\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    Depositor memory oldDepositor = depositIdToDepositor[depositIdToOverwrite];\r\n\r\n    depositIdToDepositor[depositIdToOverwrite] = Depositor(\r\n      user,\r\n      depositAmountAfterFee,\r\n      priceId\r\n    );\r\n\r\n    emit DepositorOverwritten(\r\n      depositIdToOverwrite,\r\n      oldDepositor.user,\r\n      user,\r\n      oldDepositor.priceId,\r\n      priceId,\r\n      oldDepositor.amountDepositedMinusFees,\r\n      depositAmountAfterFee\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to overwrite entries in the redemptionIdToRedeemer\r\n   *         mapping\r\n   *\r\n   * @param redemptionIdToOverwrite The redemptionId of the entry we wish to\r\n   *                                overwrite\r\n   * @param user                    The user for the new entry\r\n   * @param rwaTokenAmountBurned    The burn amount for the new entry\r\n   * @param priceId                 The priceID to be associated with the new\r\n   *                                entry\r\n   */\r\n  function overwriteRedeemer(\r\n    bytes32 redemptionIdToOverwrite,\r\n    address user,\r\n    uint256 rwaTokenAmountBurned,\r\n    uint256 priceId\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    Redeemer memory oldRedeemer = redemptionIdToRedeemer[\r\n      redemptionIdToOverwrite\r\n    ];\r\n    redemptionIdToRedeemer[redemptionIdToOverwrite] = Redeemer(\r\n      user,\r\n      rwaTokenAmountBurned,\r\n      priceId\r\n    );\r\n    emit RedeemerOverwritten(\r\n      redemptionIdToOverwrite,\r\n      oldRedeemer.user,\r\n      user,\r\n      oldRedeemer.priceId,\r\n      priceId,\r\n      oldRedeemer.amountRwaTokenBurned,\r\n      rwaTokenAmountBurned\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set the minimum amount to redeem\r\n   *\r\n   * @param _minimumRedemptionAmount The minimum amount required to submit a\r\n   *                                 redemption request\r\n   */\r\n  function setMinimumRedemptionAmount(\r\n    uint256 _minimumRedemptionAmount\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    if (_minimumRedemptionAmount < BPS_DENOMINATOR) {\r\n      revert AmountTooSmall();\r\n    }\r\n    uint256 oldRedeemMinimum = minimumRedemptionAmount;\r\n    minimumRedemptionAmount = _minimumRedemptionAmount;\r\n    emit MinimumRedemptionAmountSet(oldRedeemMinimum, _minimumRedemptionAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set the minimum amount required for a deposit\r\n   *\r\n   * @param minDepositAmount The minimum amount required to submit a deposit\r\n   *                         request\r\n   */\r\n  function setMinimumDepositAmount(\r\n    uint256 minDepositAmount\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    if (minDepositAmount < BPS_DENOMINATOR) {\r\n      revert AmountTooSmall();\r\n    }\r\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\r\n    minimumDepositAmount = minDepositAmount;\r\n    emit MinimumDepositAmountSet(oldMinimumDepositAmount, minDepositAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set the mint fee\r\n   *\r\n   * @param _mintFee The new mint fee specified in basis points\r\n   *\r\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\r\n   */\r\n  function setMintFee(uint256 _mintFee) external onlyRole(MANAGER_ADMIN) {\r\n    if (_mintFee > BPS_DENOMINATOR) {\r\n      revert FeeTooLarge();\r\n    }\r\n    uint256 oldMintFee = mintFee;\r\n    mintFee = _mintFee;\r\n    emit MintFeeSet(oldMintFee, _mintFee);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set the redeem fee\r\n   *\r\n   * @param _redemptionFee The new redeem fee specified in basis points\r\n   *\r\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\r\n   */\r\n  function setRedemptionFee(\r\n    uint256 _redemptionFee\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    if (_redemptionFee > BPS_DENOMINATOR) {\r\n      revert FeeTooLarge();\r\n    }\r\n    uint256 oldRedeemFee = redemptionFee;\r\n    redemptionFee = _redemptionFee;\r\n    emit RedemptionFeeSet(oldRedeemFee, _redemptionFee);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set the address of the Pricer contract\r\n   *\r\n   * @param newPricer The address of the new pricer contract\r\n   */\r\n  function setPricer(address newPricer) external onlyRole(MANAGER_ADMIN) {\r\n    address oldPricer = address(pricer);\r\n    pricer = IPricerReader(newPricer);\r\n    emit NewPricerSet(oldPricer, newPricer);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set the address of `feeRecipient`\r\n   *\r\n   * @param newFeeRecipient The address of the new `feeRecipient`\r\n   */\r\n  function setFeeRecipient(\r\n    address newFeeRecipient\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    address oldFeeRecipient = feeRecipient;\r\n    feeRecipient = newFeeRecipient;\r\n    emit FeeRecipientSet(oldFeeRecipient, feeRecipient);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to set the address of `assetSender`\r\n   *\r\n   * @param newAssetSender The address of the new `assetSender`\r\n   */\r\n  function setAssetSender(\r\n    address newAssetSender\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    address oldAssetSender = assetSender;\r\n    assetSender = newAssetSender;\r\n    emit AssetSenderSet(oldAssetSender, newAssetSender);\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                            Pause Utils\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Modifier to check if a feature is paused\r\n   *\r\n   * @param feature The feature to check if paused\r\n   */\r\n  modifier ifNotPaused(bool feature) {\r\n    if (feature) {\r\n      revert FeaturePaused();\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Function to pause subscription to RWAHub\r\n   */\r\n  function pauseSubscription() external onlyRole(PAUSER_ADMIN) {\r\n    subscriptionPaused = true;\r\n    emit SubscriptionPaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Function to pause redemptions to RWAHub\r\n   */\r\n  function pauseRedemption() external onlyRole(PAUSER_ADMIN) {\r\n    redemptionPaused = true;\r\n    emit RedemptionPaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Function to unpause subscriptions to RWAHub\r\n   */\r\n  function unpauseSubscription() external onlyRole(MANAGER_ADMIN) {\r\n    subscriptionPaused = false;\r\n    emit SubscriptionUnpaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Function to unpause redemptions to RWAHub\r\n   */\r\n  function unpauseRedemption() external onlyRole(MANAGER_ADMIN) {\r\n    redemptionPaused = false;\r\n    emit RedemptionUnpaused(msg.sender);\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                      Check Restriction Utils\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Modifier to check restrictions status of an account\r\n   *\r\n   * @param account The account to check\r\n   */\r\n  /*modifier checkRestrictions(address account) {\r\n    _checkRestrictions(account);\r\n    _;\r\n  }*/\r\n\r\n  /**\r\n   * @notice internal function to check restriction status\r\n   *         of an address\r\n   *\r\n   * @param account The account to check restriction status for\r\n   *\r\n   * @dev This function is virtual to be overridden by child contract\r\n   *      to check restrictions on a more granular level\r\n   */\r\n  //function _checkRestrictions(address account) internal view virtual;\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                           Math Utils\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Given amount of `collateral`, returns how much in fees\r\n   *         are owed\r\n   *\r\n   *\r\n   * @param collateralAmount Amount `collateral` to calculate fees\r\n   *                         (in decimals of `collateral`)\r\n   */\r\n  function _getMintFees(\r\n    uint256 collateralAmount\r\n  ) internal view returns (uint256) {\r\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\r\n  }\r\n\r\n  /**\r\n   * @notice Given amount of `collateral`, returns how much in fees\r\n   *         are owed\r\n   *\r\n   * @param collateralAmount Amount of `collateral` to calculate fees\r\n   *                         (in decimals of `collateral`)\r\n   */\r\n  function _getRedemptionFees(\r\n    uint256 collateralAmount\r\n  ) internal view returns (uint256) {\r\n    return (collateralAmount * redemptionFee) / BPS_DENOMINATOR;\r\n  }\r\n\r\n  /**\r\n   * @notice Given a deposit amount and priceId, returns the amount\r\n   *         of `rwa` due\r\n   *\r\n   * @param depositAmt The amount deposited in units of `collateral`\r\n   * @param price      The price associated with this deposit\r\n   */\r\n  function _getMintAmountForPrice(\r\n    uint256 depositAmt,\r\n    uint256 price\r\n  ) internal view returns (uint256 rwaAmountOut) {\r\n    uint256 amountE36 = _scaleUp(depositAmt) * 1e18;\r\n    // Will revert with div by 0 if price not defined for a priceId\r\n    rwaAmountOut = amountE36 / price;\r\n  }\r\n\r\n  /**\r\n   * @notice Given a redemption amount and a priceId, returns the amount\r\n   *         of `collateral` due\r\n   *\r\n   * @param rwaTokenAmountBurned The amount of `rwa` burned for a redemption\r\n   * @param price                The price associated with this redemption\r\n   */\r\n  function _getRedemptionAmountForRwa(\r\n    uint256 rwaTokenAmountBurned,\r\n    uint256 price\r\n  ) internal view returns (uint256 collateralOwed) {\r\n    uint256 amountE36 = rwaTokenAmountBurned * price;\r\n    collateralOwed = _scaleDown(amountE36 / 1e18);\r\n  }\r\n\r\n  /**\r\n   * @notice Scale provided amount up by `decimalsMultiplier`\r\n   *\r\n   * @dev This helper is used for converting the collateral's decimals\r\n   *      representation to the RWA amount decimals representation.\r\n   */\r\n  function _scaleUp(uint256 amount) internal view returns (uint256) {\r\n    return amount * decimalsMultiplier;\r\n  }\r\n\r\n  /**\r\n   * @notice Scale provided amount down by `decimalsMultiplier`\r\n   *\r\n   * @dev This helper is used for converting `rwa`'s decimal\r\n   *      representation to the `collateral`'s decimal representation\r\n   */\r\n  function _scaleDown(uint256 amount) internal view returns (uint256) {\r\n    return amount / decimalsMultiplier;\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IPricerReader.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IPricerReader {\r\n  /**\r\n   * @notice Gets the latest price of the asset\r\n   *\r\n   * @return uint256 The latest price of the asset\r\n   */\r\n  function getLatestPrice() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Gets the price of the asset at a specific priceId\r\n   *\r\n   * @param priceId The priceId at which to get the price\r\n   *\r\n   * @return uint256 The price of the asset with the given priceId\r\n   */\r\n  function getPrice(uint256 priceId) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IRWALike.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n */\r\npragma solidity 0.8.16;\r\n\r\n// This interface is not inherited directly by RWA, instead, it is a\r\n// subset of functions provided by all RWA tokens that the RWA Hub\r\n// Client uses.\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\r\n\r\ninterface IRWALike is IERC20 {\r\n  function mint(address to, uint256 amount) external;\r\n\r\n  function burn(uint256 amount) external;\r\n\r\n  function burnFrom(address from, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/IRWAHub.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IRWAHub {\r\n  // Struct to contain the deposit information for a given depositId\r\n  struct Depositor {\r\n    address user;\r\n    uint256 amountDepositedMinusFees;\r\n    uint256 priceId;\r\n  }\r\n\r\n  // Struc to contain withdrawal infromation for a given redemptionId\r\n  struct Redeemer {\r\n    address user;\r\n    uint256 amountRwaTokenBurned;\r\n    uint256 priceId;\r\n  }\r\n\r\n  function requestSubscription(uint256 amount) external;\r\n\r\n  function claimMint(bytes32[] calldata depositIds) external;\r\n\r\n  function requestRedemption(uint256 amount) external;\r\n\r\n  function claimRedemption(bytes32[] calldata redemptionIds) external;\r\n\r\n  function addProof(\r\n    bytes32 txHash,\r\n    address user,\r\n    uint256 depositAmountAfterFee,\r\n    uint256 feeAmount,\r\n    uint256 timestamp\r\n  ) external;\r\n\r\n  function setPriceIdForDeposits(\r\n    bytes32[] calldata depositIds,\r\n    uint256[] calldata priceIds\r\n  ) external;\r\n\r\n  function setPriceIdForRedemptions(\r\n    bytes32[] calldata redemptionIds,\r\n    uint256[] calldata priceIds\r\n  ) external;\r\n\r\n  function setPricer(address newPricer) external;\r\n\r\n  function overwriteDepositor(\r\n    bytes32 depositIdToOverride,\r\n    address user,\r\n    uint256 depositAmountAfterFee,\r\n    uint256 priceId\r\n  ) external;\r\n\r\n  function overwriteRedeemer(\r\n    bytes32 redemptionIdToOverride,\r\n    address user,\r\n    uint256 rwaTokenAmountBurned,\r\n    uint256 priceId\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Event emitted when fee recipient is set\r\n   *\r\n   * @param oldFeeRecipient Old fee recipient\r\n   * @param newFeeRecipient New fee recipient\r\n   */\r\n  event FeeRecipientSet(address oldFeeRecipient, address newFeeRecipient);\r\n\r\n  /**\r\n   * @notice Event emitted when the assetSender is changed\r\n   *\r\n   * @param oldAssetSender The address of the old assetSender\r\n   * @param newAssetSender The address of the new assetSender\r\n   */\r\n  event AssetSenderSet(address oldAssetSender, address newAssetSender);\r\n\r\n  /**\r\n   * @notice Event emitted when minimum deposit amount is set\r\n   *\r\n   * @param oldMinimum Old minimum\r\n   * @param newMinimum New minimum\r\n   *\r\n   * @dev See inheriting contract for decimals representation\r\n   */\r\n  event MinimumDepositAmountSet(uint256 oldMinimum, uint256 newMinimum);\r\n\r\n  /**\r\n   * @notice Event emitted when a new redeem minimum is set.\r\n   *         All units are in 1e18\r\n   *\r\n   * @param oldRedemptionMin The old redeem minimum value\r\n   * @param newRedemptionMin The new redeem minimum value\r\n   */\r\n  event MinimumRedemptionAmountSet(\r\n    uint256 oldRedemptionMin,\r\n    uint256 newRedemptionMin\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when mint fee is set\r\n   *\r\n   * @param oldFee Old fee\r\n   * @param newFee New fee\r\n   *\r\n   * @dev See inheriting contract for decimals representation\r\n   */\r\n  event MintFeeSet(uint256 oldFee, uint256 newFee);\r\n\r\n  /**\r\n   * @notice Event emitted when redeem fee is set\r\n   *\r\n   * @param oldFee Old fee\r\n   * @param newFee New fee\r\n   *\r\n   * @dev see inheriting contract for decimal representation\r\n   */\r\n  event RedemptionFeeSet(uint256 oldFee, uint256 newFee);\r\n\r\n  /**\r\n   * @notice Event emitted when redemption request is submitted\r\n   *\r\n   * @param user         The user submitting the redemption request\r\n   * @param redemptionId The id corresponding to a given redemption\r\n   * @param rwaAmountIn  The amount of cash being burned\r\n   */\r\n  event RedemptionRequested(\r\n    address indexed user,\r\n    bytes32 indexed redemptionId,\r\n    uint256 rwaAmountIn\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when a mint request is submitted\r\n   *\r\n   * @param user                      The user requesting to mint\r\n   * @param depositId                 The depositId of the request\r\n   * @param collateralAmountDeposited The total amount deposited\r\n   * @param depositAmountAfterFee     The value deposited - fee\r\n   * @param feeAmount                 The fee amount taken\r\n   *                                  (units of collateral)\r\n   */\r\n  event MintRequested(\r\n    address indexed user,\r\n    bytes32 indexed depositId,\r\n    uint256 collateralAmountDeposited,\r\n    uint256 depositAmountAfterFee,\r\n    uint256 feeAmount\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when a redemption request is completed\r\n   *\r\n   * @param user                     The address of the user getting the funds\r\n   * @param redemptionId             The id corresponding to a given redemption\r\n   *                                 requested\r\n   * @param rwaAmountRequested       Amount of RWA originally requested by the user\r\n   * @param collateralAmountReturned Amount of collateral received by the user\r\n   * @param price                    The price at which the redemption was\r\n   *                                 serviced at\r\n   */\r\n  event RedemptionCompleted(\r\n    address indexed user,\r\n    bytes32 indexed redemptionId,\r\n    uint256 rwaAmountRequested,\r\n    uint256 collateralAmountReturned,\r\n    uint256 price\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when a Mint request is completed\r\n   *\r\n   * @param user                      The address of the user getting the funds\r\n   * @param depositId                 The depositId of the mint request\r\n   * @param rwaAmountOut              The amount of RWA token minted to the\r\n   *                                  user\r\n   * @param collateralAmountDeposited The amount of collateral deposited\r\n   * @param price                     The price set for the given\r\n   *                                  deposit id\r\n   * @param priceId                   The priceId used to determine price\r\n   */\r\n  event MintCompleted(\r\n    address indexed user,\r\n    bytes32 indexed depositId,\r\n    uint256 rwaAmountOut,\r\n    uint256 collateralAmountDeposited,\r\n    uint256 price,\r\n    uint256 priceId\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when a deposit has its corresponding priceId set\r\n   *\r\n   * @param depositIdSet The Deposit Id for which the price Id is being set\r\n   * @param priceIdSet   The price Id being associate with a deposit Id\r\n   */\r\n  event PriceIdSetForDeposit(\r\n    bytes32 indexed depositIdSet,\r\n    uint256 indexed priceIdSet\r\n  );\r\n\r\n  /**\r\n   * @notice Event Emitted when a redemption has its corresponding priceId set\r\n   *\r\n   * @param redemptionIdSet The Redemption Id for which the price Id is being\r\n   *                        set\r\n   * @param priceIdSet      The Price Id being associated with a redemption Id\r\n   */\r\n  event PriceIdSetForRedemption(\r\n    bytes32 indexed redemptionIdSet,\r\n    uint256 indexed priceIdSet\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when a new Pricer contract is set\r\n   *\r\n   * @param oldPricer The address of the old pricer contract\r\n   * @param newPricer The address of the new pricer contract\r\n   */\r\n  event NewPricerSet(address oldPricer, address newPricer);\r\n\r\n  /**\r\n   * @notice Event emitted when deposit proof has been added\r\n   *\r\n   * @param txHash                Tx hash of the deposit\r\n   * @param user                  Address of the user who made the deposit\r\n   * @param depositAmountAfterFee Amount of the deposit after fees\r\n   * @param feeAmount             Amount of fees taken\r\n   * @param timestamp             Timestamp of the deposit\r\n   */\r\n  event DepositProofAdded(\r\n    bytes32 indexed txHash,\r\n    address indexed user,\r\n    uint256 depositAmountAfterFee,\r\n    uint256 feeAmount,\r\n    uint256 timestamp\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when subscriptions are paused\r\n   *\r\n   * @param caller Address which initiated the pause\r\n   */\r\n  event SubscriptionPaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when redemptions are paused\r\n   *\r\n   * @param caller Address which initiated the pause\r\n   */\r\n  event RedemptionPaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when subscriptions are unpaused\r\n   *\r\n   * @param caller Address which initiated the unpause\r\n   */\r\n  event SubscriptionUnpaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when redemptions are unpaused\r\n   *\r\n   * @param caller Address which initiated the unpause\r\n   */\r\n  event RedemptionUnpaused(address caller);\r\n\r\n  event DepositorOverwritten(\r\n    bytes32 indexed depositId,\r\n    address oldDepositor,\r\n    address newDepositor,\r\n    uint256 oldPriceId,\r\n    uint256 newPriceId,\r\n    uint256 oldDepositAmount,\r\n    uint256 newDepositAmount\r\n  );\r\n\r\n  event RedeemerOverwritten(\r\n    bytes32 indexed redemptionId,\r\n    address oldRedeemer,\r\n    address newRedeemer,\r\n    uint256 oldPriceId,\r\n    uint256 newPriceId,\r\n    uint256 oldRWATokenAmountBurned,\r\n    uint256 newRWATokenAmountBurned\r\n  );\r\n\r\n  /// ERRORS ///\r\n  error PriceIdNotSet();\r\n  error ArraySizeMismatch();\r\n  error DepositTooSmall();\r\n  error RedemptionTooSmall();\r\n  error TxnAlreadyValidated();\r\n  error CollateralCannotBeZero();\r\n  error RWACannotBeZero();\r\n  error AssetSenderCannotBeZero();\r\n  error FeeRecipientCannotBeZero();\r\n  error FeeTooLarge();\r\n  error AmountTooSmall();\r\n  error DepositorNull();\r\n  error RedeemerNull();\r\n  error DepositProofAlreadyExists();\r\n  error FeaturePaused();\r\n  error PriceIdAlreadySet();\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the decimals places of the token.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol\";\r\n\r\n/**\r\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\r\n */\r\nabstract contract AccessControlEnumerable is\r\n  IAccessControlEnumerable,\r\n  AccessControl\r\n{\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IAccessControlEnumerable).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns one of the accounts that have `role`. `index` must be a\r\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n   *\r\n   * Role bearers are not sorted in any particular way, and their ordering may\r\n   * change at any point.\r\n   *\r\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n   * you perform all queries on the same block. See the following\r\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n   * for more information.\r\n   */\r\n  function getRoleMember(bytes32 role, uint256 index)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (address)\r\n  {\r\n    return _roleMembers[role].at(index);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of accounts that have `role`. Can be used\r\n   * together with {getRoleMember} to enumerate all bearers of a role.\r\n   */\r\n  function getRoleMemberCount(bytes32 role)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _roleMembers[role].length();\r\n  }\r\n\r\n  /**\r\n   * @dev Overload {_grantRole} to track enumerable memberships\r\n   */\r\n  function _grantRole(bytes32 role, address account) internal virtual override {\r\n    super._grantRole(role, account);\r\n    _roleMembers[role].add(account);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload {_revokeRole} to track enumerable memberships\r\n   */\r\n  function _revokeRole(bytes32 role, address account)\r\n    internal\r\n    virtual\r\n    override\r\n  {\r\n    super._revokeRole(role, account);\r\n    _roleMembers[role].remove(account);\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n  // Booleans are more expensive than uint256 or any type that takes up a full\r\n  // word because each write operation emits an extra SLOAD to first read the\r\n  // slot's contents, replace the bits taken up by the boolean, and then write\r\n  // back. This is the compiler's defense against contract upgrades and\r\n  // pointer aliasing, and it cannot be disabled.\r\n\r\n  // The values being non-zero value makes deployment a bit more expensive,\r\n  // but in exchange the refund on every call to nonReentrant will be lower in\r\n  // amount. Since refunds are capped to a percentage of the total\r\n  // transaction's gas, it is best to keep them low in cases like this one, to\r\n  // increase the likelihood of the full refund coming into effect.\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n\r\n  uint256 private _status;\r\n\r\n  constructor() {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and making it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    // On the first call to nonReentrant, _notEntered will be true\r\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n    // Any calls to nonReentrant after this point will fail\r\n    _status = _ENTERED;\r\n\r\n    _;\r\n\r\n    // By storing the original value once again, a refund is triggered (see\r\n    // https://eips.ethereum.org/EIPS/eip-2200)\r\n    _status = _NOT_ENTERED;\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\r\n\r\n/**\r\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\r\n */\r\ninterface IAccessControlEnumerable is IAccessControl {\r\n  /**\r\n   * @dev Returns one of the accounts that have `role`. `index` must be a\r\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n   *\r\n   * Role bearers are not sorted in any particular way, and their ordering may\r\n   * change at any point.\r\n   *\r\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n   * you perform all queries on the same block. See the following\r\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n   * for more information.\r\n   */\r\n  function getRoleMember(bytes32 role, uint256 index)\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns the number of accounts that have `role`. Can be used\r\n   * together with {getRoleMember} to enumerate all bearers of a role.\r\n   */\r\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/ERC165.sol\";\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n  struct RoleData {\r\n    mapping(address => bool) members;\r\n    bytes32 adminRole;\r\n  }\r\n\r\n  mapping(bytes32 => RoleData) private _roles;\r\n\r\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n  /**\r\n   * @dev Modifier that checks that an account has a specific role. Reverts\r\n   * with a standardized message including the required role.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n   *\r\n   * _Available since v4.1._\r\n   */\r\n  modifier onlyRole(bytes32 role) {\r\n    _checkRole(role, _msgSender());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IAccessControl).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns `true` if `account` has been granted `role`.\r\n   */\r\n  function hasRole(bytes32 role, address account)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return _roles[role].members[account];\r\n  }\r\n\r\n  /**\r\n   * @dev Revert with a standard message if `account` is missing `role`.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n   */\r\n  function _checkRole(bytes32 role, address account) internal view virtual {\r\n    if (!hasRole(role, account)) {\r\n      revert(\r\n        string(\r\n          abi.encodePacked(\r\n            \"AccessControl: account \",\r\n            Strings.toHexString(uint160(account), 20),\r\n            \" is missing role \",\r\n            Strings.toHexString(uint256(role), 32)\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n   * {revokeRole}.\r\n   *\r\n   * To change a role's admin, use {_setRoleAdmin}.\r\n   */\r\n  function getRoleAdmin(bytes32 role)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bytes32)\r\n  {\r\n    return _roles[role].adminRole;\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function grantRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function revokeRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from the calling account.\r\n   *\r\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n   * purpose is to provide a mechanism for accounts to lose their privileges\r\n   * if they are compromised (such as when a trusted device is misplaced).\r\n   *\r\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must be `account`.\r\n   */\r\n  function renounceRole(bytes32 role, address account) public virtual override {\r\n    require(\r\n      account == _msgSender(),\r\n      \"AccessControl: can only renounce roles for self\"\r\n    );\r\n\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event. Note that unlike {grantRole}, this function doesn't perform any\r\n   * checks on the calling account.\r\n   *\r\n   * [WARNING]\r\n   * ====\r\n   * This function should only be called from the constructor when setting\r\n   * up the initial roles for the system.\r\n   *\r\n   * Using this function in any other way is effectively circumventing the admin\r\n   * system imposed by {AccessControl}.\r\n   * ====\r\n   *\r\n   * NOTE: This function is deprecated in favor of {_grantRole}.\r\n   */\r\n  function _setupRole(bytes32 role, address account) internal virtual {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `adminRole` as ``role``'s admin role.\r\n   *\r\n   * Emits a {RoleAdminChanged} event.\r\n   */\r\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n    bytes32 previousAdminRole = getRoleAdmin(role);\r\n    _roles[role].adminRole = adminRole;\r\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * Internal function without access restriction.\r\n   */\r\n  function _grantRole(bytes32 role, address account) internal virtual {\r\n    if (!hasRole(role, account)) {\r\n      _roles[role].members[account] = true;\r\n      emit RoleGranted(role, account, _msgSender());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * Internal function without access restriction.\r\n   */\r\n  function _revokeRole(bytes32 role, address account) internal virtual {\r\n    if (hasRole(role, account)) {\r\n      _roles[role].members[account] = false;\r\n      emit RoleRevoked(role, account, _msgSender());\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n  // To implement this library for multiple types with as little code\r\n  // repetition as possible, we write it in terms of a generic Set type with\r\n  // bytes32 values.\r\n  // The Set implementation uses private functions, and user-facing\r\n  // implementations (such as AddressSet) are just wrappers around the\r\n  // underlying Set.\r\n  // This means that we can only create new EnumerableSets for types that fit\r\n  // in bytes32.\r\n\r\n  struct Set {\r\n    // Storage of set values\r\n    bytes32[] _values;\r\n    // Position of the value in the `values` array, plus 1 because index 0\r\n    // means a value is not in the set.\r\n    mapping(bytes32 => uint256) _indexes;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function _add(Set storage set, bytes32 value) private returns (bool) {\r\n    if (!_contains(set, value)) {\r\n      set._values.push(value);\r\n      // The value is stored at length-1, but we add 1 to all indexes\r\n      // and use 0 as a sentinel value\r\n      set._indexes[value] = set._values.length;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n    // We read and store the value's index to prevent multiple reads from the same storage slot\r\n    uint256 valueIndex = set._indexes[value];\r\n\r\n    if (valueIndex != 0) {\r\n      // Equivalent to contains(set, value)\r\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n      // This modifies the order of the array, as noted in {at}.\r\n\r\n      uint256 toDeleteIndex = valueIndex - 1;\r\n      uint256 lastIndex = set._values.length - 1;\r\n\r\n      if (lastIndex != toDeleteIndex) {\r\n        bytes32 lastvalue = set._values[lastIndex];\r\n\r\n        // Move the last value to the index where the value to delete is\r\n        set._values[toDeleteIndex] = lastvalue;\r\n        // Update the index for the moved value\r\n        set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n      }\r\n\r\n      // Delete the slot where the moved value was stored\r\n      set._values.pop();\r\n\r\n      // Delete the index for the deleted slot\r\n      delete set._indexes[value];\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function _contains(Set storage set, bytes32 value)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return set._indexes[value] != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function _length(Set storage set) private view returns (uint256) {\r\n    return set._values.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n    return set._values[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function _values(Set storage set) private view returns (bytes32[] memory) {\r\n    return set._values;\r\n  }\r\n\r\n  // Bytes32Set\r\n\r\n  struct Bytes32Set {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _add(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(Bytes32Set storage set, bytes32 value)\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return _remove(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(Bytes32Set storage set, bytes32 value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(Bytes32Set storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(Bytes32Set storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return _at(set._inner, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(Bytes32Set storage set)\r\n    internal\r\n    view\r\n    returns (bytes32[] memory)\r\n  {\r\n    return _values(set._inner);\r\n  }\r\n\r\n  // AddressSet\r\n\r\n  struct AddressSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(AddressSet storage set, address value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(AddressSet storage set, address value)\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(AddressSet storage set, address value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(AddressSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(AddressSet storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(uint160(uint256(_at(set._inner, index))));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(AddressSet storage set)\r\n    internal\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    bytes32[] memory store = _values(set._inner);\r\n    address[] memory result;\r\n\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // UintSet\r\n\r\n  struct UintSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(UintSet storage set, uint256 value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function length(UintSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(UintSet storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return uint256(_at(set._inner, index));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(UintSet storage set)\r\n    internal\r\n    view\r\n    returns (uint256[] memory)\r\n  {\r\n    bytes32[] memory store = _values(set._inner);\r\n    uint256[] memory result;\r\n\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n  /**\r\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n   *\r\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n   * {RoleAdminChanged} not being emitted signaling this.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  event RoleAdminChanged(\r\n    bytes32 indexed role,\r\n    bytes32 indexed previousAdminRole,\r\n    bytes32 indexed newAdminRole\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is granted `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call, an admin role\r\n   * bearer except when using {AccessControl-_setupRole}.\r\n   */\r\n  event RoleGranted(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is revoked `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call:\r\n   *   - if using `revokeRole`, it is the admin role bearer\r\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n   */\r\n  event RoleRevoked(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Returns `true` if `account` has been granted `role`.\r\n   */\r\n  function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n   * {revokeRole}.\r\n   *\r\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n   */\r\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function grantRole(bytes32 role, address account) external;\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function revokeRole(bytes32 role, address account) external;\r\n\r\n  /**\r\n   * @dev Revokes `role` from the calling account.\r\n   *\r\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n   * purpose is to provide a mechanism for accounts to lose their privileges\r\n   * if they are compromised (such as when a trusted device is misplaced).\r\n   *\r\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must be `account`.\r\n   */\r\n  function renounceRole(bytes32 role, address account) external;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/utils/IERC165.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return interfaceId == type(IERC165).interfaceId;\r\n  }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
    },
    "contracts/RWAHubOffChainRedemptions.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\n\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/RWAHub.sol\";\r\nimport \"contracts/interfaces/IRWAHubOffChainRedemptions.sol\";\r\n\r\nabstract contract RWAHubOffChainRedemptions is\r\n  RWAHub,\r\n  IRWAHubOffChainRedemptions\r\n{\r\n  // To enable and disable off chain redemptions\r\n  bool public offChainRedemptionPaused;\r\n\r\n  // Minimum off chain redemption amount\r\n  uint256 public minimumOffChainRedemptionAmount;\r\n\r\n  constructor(\r\n    address _collateral,\r\n    address _rwa,\r\n    address managerAdmin,\r\n    address pauser,\r\n    address _assetSender,\r\n    address _feeRecipient,\r\n    uint256 _minimumDepositAmount,\r\n    uint256 _minimumRedemptionAmount\r\n  )\r\n    RWAHub(\r\n      _collateral,\r\n      _rwa,\r\n      managerAdmin,\r\n      pauser,\r\n      _assetSender,\r\n      _feeRecipient,\r\n      _minimumDepositAmount,\r\n      _minimumRedemptionAmount\r\n    )\r\n  {\r\n    // Default to the same minimum redemption amount as for On-Chain\r\n    // redemptions.\r\n    minimumOffChainRedemptionAmount = _minimumRedemptionAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Request a redemption to be serviced off chain.\r\n   *\r\n   * @param amountRWATokenToRedeem The requested redemption amount\r\n   * @param offChainDestination    A hash of the destination to which\r\n   *                               the request should be serviced to.\r\n   */\r\n  function requestRedemptionServicedOffchain(\r\n    uint256 amountRWATokenToRedeem,\r\n    bytes32 offChainDestination\r\n  ) external nonReentrant ifNotPaused(offChainRedemptionPaused) {\r\n    if (amountRWATokenToRedeem < minimumOffChainRedemptionAmount) {\r\n      revert RedemptionTooSmall();\r\n    }\r\n\r\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\r\n\r\n    rwa.burnFrom(msg.sender, amountRWATokenToRedeem);\r\n\r\n    emit RedemptionRequestedServicedOffChain(\r\n      msg.sender,\r\n      redemptionId,\r\n      amountRWATokenToRedeem,\r\n      offChainDestination\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Function to pause off chain redemptoins\r\n   */\r\n  function pauseOffChainRedemption() external onlyRole(PAUSER_ADMIN) {\r\n    offChainRedemptionPaused = true;\r\n    emit OffChainRedemptionPaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Function to unpause off chain redemptoins\r\n   */\r\n  function unpauseOffChainRedemption() external onlyRole(MANAGER_ADMIN) {\r\n    offChainRedemptionPaused = false;\r\n    emit OffChainRedemptionUnpaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin Function to set the minimum off chain redemption amount\r\n   *\r\n   * @param _minimumOffChainRedemptionAmount The new minimum off chain\r\n   *                                         redemption amount\r\n   */\r\n  function setOffChainRedemptionMinimum(\r\n    uint256 _minimumOffChainRedemptionAmount\r\n  ) external onlyRole(MANAGER_ADMIN) {\r\n    uint256 oldMinimum = minimumOffChainRedemptionAmount;\r\n    minimumOffChainRedemptionAmount = _minimumOffChainRedemptionAmount;\r\n    emit OffChainRedemptionMinimumSet(\r\n      oldMinimum,\r\n      _minimumOffChainRedemptionAmount\r\n    );\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IRWAHubOffChainRedemptions.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IRWAHubOffChainRedemptions {\r\n  function requestRedemptionServicedOffchain(\r\n    uint256 amountRWATokenToRedeem,\r\n    bytes32 offChainDestination\r\n  ) external;\r\n\r\n  function pauseOffChainRedemption() external;\r\n\r\n  function unpauseOffChainRedemption() external;\r\n\r\n  function setOffChainRedemptionMinimum(uint256 minimumAmount) external;\r\n\r\n  /**\r\n   * @notice Event emitted when redemption request is submitted\r\n   *\r\n   * @param user                The user submitting the offchain redemption request\r\n   * @param redemptionId        The id corresponding to a given offchain redemption request\r\n   * @param rwaTokenAmountIn    The amount of cash being burned\r\n   * @param offChainDestination Hash of destination to which the request\r\n   *                            should be serviced to\r\n   */\r\n  event RedemptionRequestedServicedOffChain(\r\n    address indexed user,\r\n    bytes32 indexed redemptionId,\r\n    uint256 rwaTokenAmountIn,\r\n    bytes32 offChainDestination\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when the off chain redemption feature is\r\n   *         paused\r\n   *\r\n   * @param caller Address which initiated the pause\r\n   */\r\n  event OffChainRedemptionPaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when the off chain redemption feature is\r\n   *         unpaused\r\n   *\r\n   * @param caller Address which initiated the unpause\r\n   */\r\n  event OffChainRedemptionUnpaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when the off chain redemption minimum is\r\n   *         updated\r\n   *\r\n   * @param oldMinimum the old minimum redemption amount\r\n   * @param newMinimum the new minimum redemption amount\r\n   */\r\n  event OffChainRedemptionMinimumSet(uint256 oldMinimum, uint256 newMinimum);\r\n}\r\n"
    },
    "contracts/usdy/USDYManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\n\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/RWAHubOffChainRedemptions.sol\";\r\n//import \"contracts/usdy/blocklist/BlocklistClient.sol\";\r\n//import \"contracts/sanctions/SanctionsListClient.sol\";\r\nimport \"contracts/interfaces/IUSDYManager.sol\";\r\n\r\ncontract USDYManager is\r\n  RWAHubOffChainRedemptions,\r\n  IUSDYManager\r\n{\r\n  bytes32 public constant TIMESTAMP_SETTER_ROLE =\r\n    keccak256(\"TIMESTAMP_SETTER_ROLE\");\r\n\r\n  mapping(bytes32 => uint256) public depositIdToClaimableTimestamp;\r\n\r\n  constructor(\r\n    address _collateral,\r\n    address _rwa,\r\n    address managerAdmin,\r\n    address pauser,\r\n    address _assetSender,\r\n    address _feeRecipient,\r\n    uint256 _minimumDepositAmount,\r\n    uint256 _minimumRedemptionAmount,\r\n    address blocklist,\r\n    address sanctionsList\r\n  )\r\n    RWAHubOffChainRedemptions(\r\n      _collateral,\r\n      _rwa,\r\n      managerAdmin,\r\n      pauser,\r\n      _assetSender,\r\n      _feeRecipient,\r\n      _minimumDepositAmount,\r\n      _minimumRedemptionAmount\r\n    )\r\n  {}\r\n\r\n  /**\r\n   * @notice Function to enforce blocklist and sanctionslist restrictions to be\r\n   *         implemented on calls to `requestSubscription` and\r\n   *         `claimRedemption`\r\n   *\r\n   * @param account The account to check blocklist and sanctions list status\r\n   *                for\r\n   */\r\n  /*function _checkRestrictions(address account) internal view override {\r\n    if (_isBlocked(account)) {\r\n      revert BlockedAccount();\r\n    }\r\n    if (_isSanctioned(account)) {\r\n      revert SanctionedAccount();\r\n    }\r\n  }*/\r\n\r\n  /**\r\n   * @notice Internal hook that is called by `claimMint` to enforce the time\r\n   *         at which a user can claim their USDY\r\n   *\r\n   * @param depositId The depositId to check the claimable timestamp for\r\n   *\r\n   * @dev This function will call the `_claimMint` function in the parent\r\n   *      once USDY-specific checks have been made\r\n   */\r\n  function _claimMint(bytes32 depositId) internal virtual override {\r\n    if (depositIdToClaimableTimestamp[depositId] == 0) {\r\n      revert ClaimableTimestampNotSet();\r\n    }\r\n\r\n    if (depositIdToClaimableTimestamp[depositId] > block.timestamp) {\r\n      revert MintNotYetClaimable();\r\n    }\r\n\r\n    super._claimMint(depositId);\r\n    delete depositIdToClaimableTimestamp[depositId];\r\n  }\r\n\r\n  /**\r\n   * @notice Update blocklist address\r\n   *\r\n   * @param blocklist The new blocklist address\r\n   */\r\n  /*function setBlocklist(\r\n    address blocklist\r\n  ) external override onlyRole(MANAGER_ADMIN) {\r\n    _setBlocklist(blocklist);\r\n  }*/\r\n\r\n  /**\r\n   * @notice Update sanctions list address\r\n   *\r\n   * @param sanctionsList The new sanctions list address\r\n   */\r\n  /*function setSanctionsList(\r\n    address sanctionsList\r\n  ) external override onlyRole(MANAGER_ADMIN) {\r\n    _setSanctionsList(sanctionsList);\r\n  }*/\r\n\r\n  /**\r\n   * @notice Set the claimable timestamp for a list of depositIds\r\n   *\r\n   * @param claimTimestamp The timestamp at which the deposit can be claimed\r\n   * @param depositIds The depositIds to set the claimable timestamp for\r\n   */\r\n  function setClaimableTimestamp(\r\n    uint256 claimTimestamp,\r\n    bytes32[] calldata depositIds\r\n  ) external onlyRole(TIMESTAMP_SETTER_ROLE) {\r\n    if (claimTimestamp < block.timestamp) {\r\n      revert ClaimableTimestampInPast();\r\n    }\r\n\r\n    uint256 depositsSize = depositIds.length;\r\n    for (uint256 i; i < depositsSize; ++i) {\r\n      depositIdToClaimableTimestamp[depositIds[i]] = claimTimestamp;\r\n      emit ClaimableTimestampSet(claimTimestamp, depositIds[i]);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IUSDYManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IUSDYManager {\r\n  function setClaimableTimestamp(\r\n    uint256 claimDate,\r\n    bytes32[] calldata depositIds\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Event emitted when claimable timestamp is set\r\n   *\r\n   * @param claimTimestamp The timestamp at which the mint can be claimed\r\n   * @param depositId      The depositId that can claim at the given \r\n                           `claimTimestamp`\r\n   */\r\n  event ClaimableTimestampSet(\r\n    uint256 indexed claimTimestamp,\r\n    bytes32 indexed depositId\r\n  );\r\n\r\n  /// ERRORS ///\r\n  error MintNotYetClaimable();\r\n  error ClaimableTimestampInPast();\r\n  error ClaimableTimestampNotSet();\r\n}\r\n"
    },
    "contracts/rwaOracles/RWAOracleRateCheck.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\n\r\ncontract RWAOracleRateCheck is IRWAOracle, AccessControlEnumerable {\r\n  // Price of RWA token (OUSG, OSTB, OHYG, etc.)\r\n  int256 public rwaPrice;\r\n\r\n  // Timestamp in which the RWA token price was last set\r\n  uint256 public priceTimestamp;\r\n\r\n  // Minimum time between price updates\r\n  uint256 public constant MIN_PRICE_UPDATE_WINDOW = 23 hours;\r\n\r\n  // Helper constant that allows us to specify basis points in calculations\r\n  uint256 public constant BPS_DENOMINATOR = 10_000;\r\n\r\n  // 1%, for example, if RWA price is 100 on day 1, it can't be more than\r\n  // 101 or less than 99 on day 2\r\n  uint256 public constant MAX_CHANGE_DIFF_BPS = 100;\r\n\r\n  // Max uint256\r\n  uint256 internal constant MAX_UINT256 = 2 ** 256 - 1;\r\n\r\n  // Role that can set RWA price\r\n  bytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\r\n\r\n  /**\r\n   * @notice Constructor\r\n   *\r\n   * @param admin The address of the admin\r\n   * @param setter The address of the setter\r\n   * @param initialprice The initial price of RWA\r\n   */\r\n  constructor(address admin, address setter, int256 initialprice) {\r\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\r\n    _grantRole(SETTER_ROLE, setter);\r\n\r\n    if (initialprice <= 0) {\r\n      revert InvalidPrice();\r\n    }\r\n\r\n    rwaPrice = initialprice;\r\n    priceTimestamp = block.timestamp;\r\n\r\n    emit RWAPriceSet(0, initialprice, block.timestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieve the last set RWA price data\r\n   *\r\n   * @dev `price` is in 18 decimals, `timestamp` is unix seconds since epoch\r\n   */\r\n  function getPriceData() external view override returns (uint256, uint256) {\r\n    return (uint256(rwaPrice), priceTimestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice Set the RWA price\r\n   *\r\n   * @param newPrice The new RWA price\r\n   *\r\n   * @dev `MAX_CHANGE_DIFF_BPS` can be a positive or negative percent deviation\r\n   */\r\n  function setPrice(int256 newPrice) external onlyRole(SETTER_ROLE) {\r\n    if (newPrice <= 0) {\r\n      revert InvalidPrice();\r\n    }\r\n    if (block.timestamp - priceTimestamp < MIN_PRICE_UPDATE_WINDOW) {\r\n      revert PriceUpdateWindowViolation();\r\n    }\r\n    if (_getPriceChangeBps(rwaPrice, newPrice) > MAX_CHANGE_DIFF_BPS) {\r\n      revert DeltaDifferenceConstraintViolation();\r\n    }\r\n\r\n    // Set new price\r\n    int256 oldPrice = rwaPrice;\r\n    rwaPrice = newPrice;\r\n    priceTimestamp = block.timestamp;\r\n\r\n    emit RWAPriceSet(oldPrice, newPrice, block.timestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice Compute the price change in basis point\r\n   *\r\n   * @param previousPrice Previous price\r\n   * @param newPrice      New price\r\n   *\r\n   * @dev The price change can be negative.\r\n   */\r\n  function _getPriceChangeBps(\r\n    int256 previousPrice,\r\n    int256 newPrice\r\n  ) private pure returns (uint256) {\r\n    uint256 change = newPrice > previousPrice\r\n      ? uint256(newPrice - previousPrice)\r\n      : uint256(previousPrice - newPrice);\r\n    uint256 changeBps = mulDivUp(\r\n      change,\r\n      BPS_DENOMINATOR,\r\n      uint256(previousPrice)\r\n    );\r\n    return changeBps;\r\n  }\r\n\r\n  /**\r\n   * @notice MulDivUp function forked from solmate's implementation\r\n   *\r\n   * @dev Forked from solmate's V6 release\r\n   */\r\n  function mulDivUp(\r\n    uint256 x,\r\n    uint256 y,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 z) {\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\r\n      if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      // If x * y modulo the denominator is strictly greater than 0,\r\n      // 1 is added to round up the division of x * y by the denominator.\r\n      z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\r\n    }\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                          Events & Errors\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Emitted when the RWA price is set\r\n   *\r\n   * @param oldPrice The old RWA price\r\n   * @param newPrice The new RWA price\r\n   * @param timestamp The timestamp at which the price was set\r\n   */\r\n  event RWAPriceSet(int256 oldPrice, int256 newPrice, uint256 timestamp);\r\n\r\n  // Errors\r\n  error InvalidPrice();\r\n  error PriceUpdateWindowViolation();\r\n  error DeltaDifferenceConstraintViolation();\r\n}\r\n"
    },
    "contracts/rwaOracles/IRWAOracle.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IRWAOracle {\r\n  /// @notice Retrieve RWA price data\r\n  function getPriceData()\r\n    external\r\n    view\r\n    returns (uint256 price, uint256 timestamp);\r\n}\r\n"
    },
    "contracts/rwaOracles/IRWAOracleExternalComparisonCheck.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\r\n\r\ninterface IRWAOracleExternalComparisonCheck is IRWAOracle {\r\n  /// @notice Set the RWA price\r\n  function setPrice(int256 newPrice) external;\r\n\r\n  /// EVENTS ///\r\n  /**\r\n   * @dev Event for when the price is set nominally\r\n   *\r\n   * @param oldChainlinkPrice Old Chainlink price\r\n   * @param oldRoundId        Chainlink round ID of old price\r\n   * @param newChainlinkPrice New Chainlink price\r\n   * @param newRoundId        Chainlink round ID of old price\r\n   * @param oldRWAPrice       Old RWA price\r\n   * @param newRWAPrice       New RWA price\r\n   */\r\n  event RWAExternalComparisonCheckPriceSet(\r\n    int256 oldChainlinkPrice,\r\n    uint80 indexed oldRoundId,\r\n    int256 newChainlinkPrice,\r\n    uint80 indexed newRoundId,\r\n    int256 oldRWAPrice,\r\n    int256 newRWAPrice\r\n  );\r\n\r\n  /**\r\n   * @dev Event for when the Chainlink price is out of reasonable bounds is\r\n   *      is ignored\r\n   *\r\n   * @param oldChainlinkPrice Old Chainlink price\r\n   * @param oldRoundId        Chainlink round ID of old price\r\n   * @param newChainlinkPrice New Chainlink price\r\n   * @param newRoundId        Chainlink round ID of old price\r\n   */\r\n  event ChainlinkPriceIgnored(\r\n    int256 oldChainlinkPrice,\r\n    uint80 indexed oldRoundId,\r\n    int256 newChainlinkPrice,\r\n    uint80 indexed newRoundId\r\n  );\r\n\r\n  /// ERRORS ///\r\n  error CorruptedChainlinkResponse();\r\n  error ChainlinkOraclePriceStale();\r\n  error DeltaDifferenceConstraintViolation();\r\n  error AbsoluteDifferenceConstraintViolated();\r\n  error PriceUpdateWindowViolation();\r\n  error InvalidRWAPrice();\r\n  error ChainlinkRoundNotUpdated();\r\n  error InvalidAddress();\r\n}\r\n"
    },
    "contracts/rwaOracles/RWAOracleExternalComparisonCheck.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\nimport \"contracts/external/chainlink/AggregatorV3Interface.sol\";\r\nimport \"contracts/rwaOracles/IRWAOracleExternalComparisonCheck.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\n\r\ncontract RWAOracleExternalComparisonCheck is\r\n  IRWAOracleExternalComparisonCheck,\r\n  AccessControlEnumerable\r\n{\r\n  /// @notice Helper struct for storing SHV data from Chainlink\r\n  struct ChainlinkRoundData {\r\n    uint80 roundId;\r\n    int256 answer;\r\n    uint256 startedAt;\r\n    uint256 updatedAt;\r\n    uint80 answeredInRound;\r\n  }\r\n\r\n  // Price of RWA token (OUSG, OSTB, OHYG, etc.)\r\n  int256 public rwaPrice;\r\n\r\n  // Timestamp in which the RWA token price was last set\r\n  uint256 public priceTimestamp;\r\n\r\n  // The associated Chainlink price update associated with the stored\r\n  // `rwaPrice`\r\n  ChainlinkRoundData public lastSetRound;\r\n\r\n  // Chainlink oracle whose tracked instrument is used to constrain price updates.\r\n  AggregatorV3Interface public immutable chainlinkOracle;\r\n\r\n  // Description of oracle set in Constructor\r\n  string public description;\r\n\r\n  // How recent a Chainlink update needs to be in order to be associated to\r\n  // a RWA price change.\r\n  uint256 public constant MAX_CL_WINDOW = 25 hours;\r\n\r\n  // Helper constant that allows us to specify basis points in calculations\r\n  int256 public constant BPS_DENOMINATOR = 10_000;\r\n\r\n  // Amount of bps that the RWA price can differ from the SHV change. For\r\n  // example, if SHV changes by 1% in between RWA price updates,\r\n  // RWA token can change between .26% and 1.74%\r\n  uint256 public constant MAX_CHANGE_DIFF_BPS = 74;\r\n\r\n  // Max amount of bps that RWA price in a single price update.\r\n  uint256 public constant MAX_ABSOLUTE_DIFF_BPS = 200;\r\n\r\n  // Minimum time between price updates\r\n  uint256 public constant MIN_PRICE_UPDATE_WINDOW = 23 hours;\r\n\r\n  /// @notice How many decimals `rwaPrice` is represented in\r\n  /// @dev UNUSED AND UNENFORCED - This is present only for operational\r\n  ///      clarity.\r\n  uint256 public constant decimals = 18;\r\n\r\n  // Role that can set RWA price\r\n  bytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\r\n\r\n  /**\r\n   * @notice constructor\r\n   *\r\n   * @param _initialPrice     The initial RWA price\r\n   * @param _chainlinkOracle Chainlink oracle to compare differences with\r\n   * @param _description     Human readable description\r\n   * @param _admin           admin which holds the DEFAULT_ADMIN_ROLE\r\n   * @param _setter          setter address which holds the role to set rwa price\r\n   */\r\n  constructor(\r\n    int256 _initialPrice,\r\n    address _chainlinkOracle,\r\n    string memory _description,\r\n    address _admin,\r\n    address _setter\r\n  ) {\r\n    if (_admin == address(0) || _setter == address(0)) {\r\n      revert InvalidAddress();\r\n    }\r\n    chainlinkOracle = AggregatorV3Interface(_chainlinkOracle);\r\n    // Revert if Chainlink oracle is not reporting 8 decimals\r\n    if (chainlinkOracle.decimals() != 8) {\r\n      revert CorruptedChainlinkResponse();\r\n    }\r\n\r\n    ChainlinkRoundData memory round = _getLatestChainlinkRoundData();\r\n    if (block.timestamp > round.updatedAt + MAX_CL_WINDOW) {\r\n      revert ChainlinkOraclePriceStale();\r\n    }\r\n\r\n    description = _description;\r\n    rwaPrice = _initialPrice;\r\n    priceTimestamp = block.timestamp;\r\n    lastSetRound = round;\r\n\r\n    _grantRole(DEFAULT_ADMIN_ROLE, _admin);\r\n    _grantRole(SETTER_ROLE, _setter);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieve the last set RWA price data\r\n   *\r\n   * @dev `price` is in 18 decimals, `timestamp` is unix seconds since epoch\r\n   */\r\n  function getPriceData()\r\n    external\r\n    view\r\n    override\r\n    returns (uint256 price, uint256 timestamp)\r\n  {\r\n    price = uint256(rwaPrice);\r\n    timestamp = priceTimestamp;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the price of RWA if all the following criteria are met:\r\n   *  - It is able to pull a consistent and recent Chainlink price that is\r\n   *    different than the last used Chainlink round\r\n   *  - The price wasn't updated too recently (`MIN_PRICE_UPDATE_WINDOW`\r\n   *    seconds)\r\n   *  - The change in RWA price is < MAX_ABSOLUTE_DIFF_BPS\r\n   *  - The change in RWA price has not deviated `MAX_CHANGE_DIFF_BPS` more\r\n   *    than the change in the Chainlink price.\r\n   * If the change in Chainlink price is larger than `MAX_ABSOLUTE_DIFF_BPS +\r\n   * MAX_CHANGE_DIFF_BPS` it is deemed malfunctioning and ignored.\r\n   *\r\n   * @param newPrice The new price of some RWA token (In `decimals` decimals)\r\n   *\r\n   * @dev The decimal representation is not enforced yet must be respected by\r\n   *      the caller of this function and deployer of this contract\r\n   */\r\n  function setPrice(int256 newPrice) external override onlyRole(SETTER_ROLE) {\r\n    // RWA price must be greater than zero\r\n    if (newPrice <= 0) {\r\n      revert InvalidRWAPrice();\r\n    }\r\n\r\n    ChainlinkRoundData memory round = _getLatestChainlinkRoundData();\r\n    // Chainlink price update must be recent\r\n    if (block.timestamp > round.updatedAt + MAX_CL_WINDOW) {\r\n      revert ChainlinkOraclePriceStale();\r\n    }\r\n\r\n    // Chainlink price update must not be comparing the same rounds against\r\n    // eachother\r\n    if (round.roundId == lastSetRound.roundId) {\r\n      revert ChainlinkRoundNotUpdated();\r\n    }\r\n\r\n    // Ensure at least `MIN_PRICE_UPDATE_WINDOW` seconds have passed since\r\n    // last RWA price update\r\n    if (block.timestamp < priceTimestamp + MIN_PRICE_UPDATE_WINDOW) {\r\n      revert PriceUpdateWindowViolation();\r\n    }\r\n\r\n    int256 rwaPriceChangeBps = _getPriceChangeBps(rwaPrice, newPrice);\r\n    // Never allow a price change that violates the max absolute change\r\n    // threshold.\r\n    if (_abs_unsigned(rwaPriceChangeBps) > MAX_ABSOLUTE_DIFF_BPS) {\r\n      revert AbsoluteDifferenceConstraintViolated();\r\n    }\r\n\r\n    int256 chainlinkPriceChangeBps = _getPriceChangeBps(\r\n      lastSetRound.answer,\r\n      round.answer\r\n    );\r\n\r\n    if (\r\n      _abs_unsigned(chainlinkPriceChangeBps) <=\r\n      MAX_ABSOLUTE_DIFF_BPS + MAX_CHANGE_DIFF_BPS\r\n    ) {\r\n      // Chainlink price change is sane, so we compare rwa price changes\r\n      // against the Chainlink price changes.\r\n      uint256 changeDifferenceBps = _abs_unsigned(\r\n        rwaPriceChangeBps - chainlinkPriceChangeBps\r\n      );\r\n\r\n      if (changeDifferenceBps > MAX_CHANGE_DIFF_BPS) {\r\n        revert DeltaDifferenceConstraintViolation();\r\n      }\r\n    } else {\r\n      emit ChainlinkPriceIgnored(\r\n        lastSetRound.answer,\r\n        lastSetRound.roundId,\r\n        round.answer,\r\n        round.roundId\r\n      );\r\n    }\r\n\r\n    emit RWAExternalComparisonCheckPriceSet(\r\n      lastSetRound.answer,\r\n      lastSetRound.roundId,\r\n      round.answer,\r\n      round.roundId,\r\n      rwaPrice,\r\n      newPrice\r\n    );\r\n\r\n    rwaPrice = newPrice;\r\n    priceTimestamp = block.timestamp;\r\n    lastSetRound = round;\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieve latest Chainlink data\r\n   *\r\n   * @dev Reverts if any corruption is detected in Chainlink response\r\n   */\r\n  function _getLatestChainlinkRoundData()\r\n    private\r\n    view\r\n    returns (ChainlinkRoundData memory round)\r\n  {\r\n    (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    ) = chainlinkOracle.latestRoundData();\r\n    if (\r\n      answer < 0 ||\r\n      roundId != answeredInRound ||\r\n      roundId == 0 ||\r\n      updatedAt == 0 ||\r\n      updatedAt > block.timestamp\r\n    ) {\r\n      revert CorruptedChainlinkResponse();\r\n    }\r\n    round = ChainlinkRoundData(\r\n      roundId,\r\n      answer,\r\n      startedAt,\r\n      updatedAt,\r\n      answeredInRound\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Compute the price change in basis point\r\n   *\r\n   * @param previousPrice Previous price\r\n   * @param newPrice      New price\r\n   *\r\n   * @dev The price change can be negative.\r\n   */\r\n  function _getPriceChangeBps(\r\n    int256 previousPrice,\r\n    int256 newPrice\r\n  ) private pure returns (int256 changeBps) {\r\n    int256 change = newPrice - previousPrice;\r\n    changeBps = (change * BPS_DENOMINATOR) / previousPrice;\r\n  }\r\n\r\n  /**\r\n   * @notice returns the absolute value of the input.\r\n   *\r\n   * @param x the number to return absolute value of.\r\n   */\r\n  function _abs_unsigned(int256 x) private pure returns (uint256) {\r\n    return x >= 0 ? uint256(x) : uint256(-x);\r\n  }\r\n}\r\n"
    },
    "contracts/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.16;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n"
    },
    "contracts/PricerWithOracle.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\n\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\nimport \"contracts/interfaces/IPricerWithOracle.sol\";\r\nimport \"contracts/Pricer.sol\";\r\nimport \"contracts/rwaOracles/IRWAOracleSetter.sol\";\r\n\r\ncontract PricerWithOracle is\r\n  AccessControlEnumerable,\r\n  Pricer,\r\n  IPricerWithOracle\r\n{\r\n  // Pointer to rwaOracle\r\n  IRWAOracleSetter public immutable rwaOracle;\r\n\r\n  constructor(\r\n    address admin,\r\n    address pricer,\r\n    address _rwaOracle\r\n  ) Pricer(admin, pricer) {\r\n    rwaOracle = IRWAOracleSetter(_rwaOracle);\r\n\r\n    // Set initial priceId data\r\n    uint256 priceId = ++currentPriceId;\r\n    (uint256 latestOraclePrice, uint256 timestamp) = rwaOracle.getPriceData();\r\n    prices[priceId] = PriceInfo(latestOraclePrice, timestamp);\r\n    priceIds.push(priceId);\r\n    latestPriceId = priceId;\r\n    emit PriceAdded(priceId, latestOraclePrice, timestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a price to the pricer\r\n   *\r\n   * @param price     The price to add\r\n   * @param timestamp The timestamp associated with the price\r\n   *\r\n   * @dev Updates the oracle price if price is the latest\r\n   */\r\n  function addPrice(\r\n    uint256 price,\r\n    uint256 timestamp\r\n  ) external override(Pricer, IPricer) onlyRole(PRICE_UPDATE_ROLE) {\r\n    if (price == 0) {\r\n      revert InvalidPrice();\r\n    }\r\n\r\n    // Set price\r\n    uint256 priceId = ++currentPriceId;\r\n    prices[priceId] = PriceInfo(price, timestamp);\r\n    priceIds.push(priceId);\r\n\r\n    // Update latestPriceId & Oracle Price\r\n    if (timestamp > prices[latestPriceId].timestamp) {\r\n      _updateOraclePrice(price, latestPriceId);\r\n      latestPriceId = priceId;\r\n    }\r\n\r\n    emit PriceAdded(priceId, price, timestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a price in the pricer to match the oracle price\r\n   *\r\n   * @dev This function can be used to \"catch-up\" the Pricer with the oracle\r\n   *      price if the latest oracle price was not set through the Pricer\r\n   */\r\n  function addLatestOraclePrice() external onlyRole(PRICE_UPDATE_ROLE) {\r\n    (uint256 latestOraclePrice, uint256 latestOraclePriceTimestamp) = rwaOracle\r\n      .getPriceData();\r\n\r\n    PriceInfo memory latestPriceInfo = prices[latestPriceId];\r\n    if (\r\n      latestPriceInfo.price == latestOraclePrice &&\r\n      latestPriceInfo.timestamp == latestOraclePriceTimestamp\r\n    ) {\r\n      revert PricesAlreadyMatch();\r\n    }\r\n\r\n    // Set price\r\n    uint256 priceId = ++currentPriceId;\r\n    prices[priceId] = PriceInfo(latestOraclePrice, latestOraclePriceTimestamp);\r\n    priceIds.push(priceId);\r\n\r\n    // Update latestPriceId. latestPriceInfo.timestamp is always\r\n    // <= latestOraclePriceTimestamp, so we can skip a check\r\n    latestPriceId = priceId;\r\n\r\n    emit PriceAdded(priceId, latestOraclePrice, latestOraclePriceTimestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice Updates the RWA oracle price\r\n   *\r\n   * @param price         The price to set in the oracle\r\n   * @param _latestPriceId The priceId associated with the latest price\r\n   */\r\n  function _updateOraclePrice(uint256 price, uint256 _latestPriceId) internal {\r\n    (uint256 latestOraclePrice, ) = rwaOracle.getPriceData();\r\n    if (prices[_latestPriceId].price != latestOraclePrice) {\r\n      revert LatestPriceMismatch();\r\n    }\r\n    rwaOracle.setPrice(int256(price));\r\n  }\r\n\r\n  // Errors\r\n  error LatestPriceMismatch();\r\n  error PricesAlreadyMatch();\r\n}\r\n"
    },
    "contracts/interfaces/IPricerWithOracle.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IPricer.sol\";\r\n\r\ninterface IPricerWithOracle is IPricer {\r\n  /**\r\n   * @notice Updates a price in the pricer by pulling it from the oracle\r\n   */\r\n  function addLatestOraclePrice() external;\r\n}\r\n"
    },
    "contracts/Pricer.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\n\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\nimport \"contracts/interfaces/IPricer.sol\";\r\n\r\ncontract Pricer is AccessControlEnumerable, IPricer {\r\n  // Struct representing information for a given priceId\r\n  struct PriceInfo {\r\n    uint256 price;\r\n    uint256 timestamp;\r\n  }\r\n  // Mapping from priceId to PriceInfo\r\n  mapping(uint256 => PriceInfo) public prices;\r\n\r\n  // Array of priceIds\r\n  /// @dev These priceIds are not ordered by timestamp\r\n  uint256[] public priceIds;\r\n\r\n  // Pointer to last set priceId\r\n  /// @dev This price may not be the latest price since prices can be added\r\n  /// out of order in relation to their timestamp\r\n  uint256 public currentPriceId;\r\n\r\n  // Pointer to priceId associated with the latest price\r\n  uint256 public latestPriceId;\r\n\r\n  bytes32 public constant PRICE_UPDATE_ROLE = keccak256(\"PRICE_UPDATE_ROLE\");\r\n\r\n  constructor(address admin, address pricer) {\r\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\r\n    _grantRole(PRICE_UPDATE_ROLE, pricer);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the latest price of the asset\r\n   *\r\n   * @return uint256 The latest price of the asset\r\n   */\r\n  function getLatestPrice() external view override returns (uint256) {\r\n    return prices[latestPriceId].price;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the latest price of the asset\r\n   *\r\n   * @return uint256 The price of the asset\r\n   */\r\n  function getPrice(uint256 priceId) external view override returns (uint256) {\r\n    return prices[priceId].price;\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a price to the pricer\r\n   *\r\n   * @param price     The price to add\r\n   * @param timestamp The timestamp associated with the price\r\n   */\r\n  function addPrice(\r\n    uint256 price,\r\n    uint256 timestamp\r\n  ) external virtual override onlyRole(PRICE_UPDATE_ROLE) {\r\n    if (price == 0) {\r\n      revert InvalidPrice();\r\n    }\r\n\r\n    // Set price\r\n    uint256 priceId = ++currentPriceId;\r\n    prices[priceId] = PriceInfo(price, timestamp);\r\n    priceIds.push(priceId);\r\n\r\n    // Update latestPriceId\r\n    if (timestamp > prices[latestPriceId].timestamp) {\r\n      latestPriceId = priceId;\r\n    }\r\n\r\n    emit PriceAdded(priceId, price, timestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice Updates a price in the pricer\r\n   *\r\n   * @param priceId The priceId to update\r\n   * @param price   The price to set\r\n   */\r\n  function updatePrice(\r\n    uint256 priceId,\r\n    uint256 price\r\n  ) external override onlyRole(PRICE_UPDATE_ROLE) {\r\n    if (price == 0) {\r\n      revert InvalidPrice();\r\n    }\r\n    if (prices[priceId].price == 0) {\r\n      revert PriceIdDoesNotExist();\r\n    }\r\n\r\n    PriceInfo memory oldPriceInfo = prices[priceId];\r\n    prices[priceId] = PriceInfo(price, oldPriceInfo.timestamp);\r\n\r\n    emit PriceUpdated(priceId, oldPriceInfo.price, price);\r\n  }\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                           Events & Errors\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  /**\r\n   * @notice Emitted when a price is added\r\n   *\r\n   * @param priceId   The priceId associated with the price\r\n   * @param price     The price that was added\r\n   * @param timestamp The timestamp associated with the price\r\n   */\r\n  event PriceAdded(uint256 indexed priceId, uint256 price, uint256 timestamp);\r\n\r\n  /**\r\n   * @notice Emitted when a price is updated\r\n   *\r\n   * @param priceId  The priceId associated with the price to update\r\n   * @param oldPrice The old price associated with the priceId\r\n   * @param newPrice The price that was updated to\r\n   */\r\n  event PriceUpdated(\r\n    uint256 indexed priceId,\r\n    uint256 oldPrice,\r\n    uint256 newPrice\r\n  );\r\n\r\n  // Errors\r\n  error InvalidPrice();\r\n  error PriceIdDoesNotExist();\r\n}\r\n"
    },
    "contracts/rwaOracles/IRWAOracleSetter.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IRWAOracleSetter {\r\n  /// @notice Retrieve RWA price data\r\n  function getPriceData()\r\n    external\r\n    view\r\n    returns (uint256 price, uint256 timestamp);\r\n\r\n  /// @notice Set the RWA price\r\n  function setPrice(int256 price) external;\r\n}\r\n"
    },
    "contracts/interfaces/IPricer.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\ninterface IPricer {\r\n  /**\r\n   * @notice Gets the latest price of the asset\r\n   *\r\n   * @return uint256 The latest price of the asset\r\n   */\r\n  function getLatestPrice() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Gets the price of the asset at a specific priceId\r\n   *\r\n   * @param priceId The priceId at which to get the price\r\n   *\r\n   * @return uint256 The price of the asset with the given priceId\r\n   */\r\n  function getPrice(uint256 priceId) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Adds a price to the pricer\r\n   *\r\n   * @param price     The price to add\r\n   * @param timestamp The timestamp associated with the price\r\n   *\r\n   * @dev Updates the oracle price if price is the latest\r\n   */\r\n  function addPrice(uint256 price, uint256 timestamp) external;\r\n\r\n  /**\r\n   * @notice Updates a price in the pricer\r\n   *\r\n   * @param priceId The priceId to update\r\n   * @param price   The price to set\r\n   */\r\n  function updatePrice(uint256 priceId, uint256 price) external;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ECDSA.sol\";\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\r\n *\r\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\r\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\r\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\r\n *\r\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\r\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\r\n * ({_hashTypedDataV4}).\r\n *\r\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\r\n * the chain id to protect against replay attacks on an eventual fork of the chain.\r\n *\r\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\r\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\r\n *\r\n * _Available since v3.4._\r\n */\r\nabstract contract EIP712 {\r\n    /* solhint-disable var-name-mixedcase */\r\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\r\n    // invalidate the cached domain separator if the chain id changes.\r\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\r\n    uint256 private immutable _CACHED_CHAIN_ID;\r\n    address private immutable _CACHED_THIS;\r\n\r\n    bytes32 private immutable _HASHED_NAME;\r\n    bytes32 private immutable _HASHED_VERSION;\r\n    bytes32 private immutable _TYPE_HASH;\r\n\r\n    /* solhint-enable var-name-mixedcase */\r\n\r\n    /**\r\n     * @dev Initializes the domain separator and parameter caches.\r\n     *\r\n     * The meaning of `name` and `version` is specified in\r\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\r\n     *\r\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\r\n     * - `version`: the current major version of the signing domain.\r\n     *\r\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\r\n     * contract upgrade].\r\n     */\r\n    constructor(string memory name, string memory version) {\r\n        bytes32 hashedName = keccak256(bytes(name));\r\n        bytes32 hashedVersion = keccak256(bytes(version));\r\n        bytes32 typeHash = keccak256(\r\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n        );\r\n        _HASHED_NAME = hashedName;\r\n        _HASHED_VERSION = hashedVersion;\r\n        _CACHED_CHAIN_ID = block.chainid;\r\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\r\n        _CACHED_THIS = address(this);\r\n        _TYPE_HASH = typeHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator for the current chain.\r\n     */\r\n    function _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\r\n            return _CACHED_DOMAIN_SEPARATOR;\r\n        } else {\r\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator(\r\n        bytes32 typeHash,\r\n        bytes32 nameHash,\r\n        bytes32 versionHash\r\n    ) private view returns (bytes32) {\r\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\r\n     * function returns the hash of the fully encoded EIP712 message for this domain.\r\n     *\r\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\r\n     *\r\n     * ```solidity\r\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\r\n     *     keccak256(\"Mail(address to,string contents)\"),\r\n     *     mailTo,\r\n     *     keccak256(bytes(mailContents))\r\n     * )));\r\n     * address signer = ECDSA.recover(digest, signature);\r\n     * ```\r\n     */\r\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\r\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\r\n    }\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/token/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\r\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n  mapping(address => uint256) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n\r\n  /**\r\n   * @dev Sets the values for {name} and {symbol}.\r\n   *\r\n   * The default value of {decimals} is 18. To select a different value for\r\n   * {decimals} you should overload it.\r\n   *\r\n   * All two of these values are immutable: they can only be set once during\r\n   * construction.\r\n   */\r\n  constructor(string memory name_, string memory symbol_) {\r\n    _name = name_;\r\n    _symbol = symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() public view virtual override returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token, usually a shorter version of the\r\n   * name.\r\n   */\r\n  function symbol() public view virtual override returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals used to get its user representation.\r\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n   *\r\n   * Tokens usually opt for a value of 18, imitating the relationship between\r\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n   * overridden;\r\n   *\r\n   * NOTE: This information is only used for _display_ purposes: it in\r\n   * no way affects any of the arithmetic of the contract, including\r\n   * {IERC20-balanceOf} and {IERC20-transfer}.\r\n   */\r\n  function decimals() public view virtual override returns (uint8) {\r\n    return 18;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-totalSupply}.\r\n   */\r\n  function totalSupply() public view virtual override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-balanceOf}.\r\n   */\r\n  function balanceOf(address account)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address to, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    _transfer(owner, to, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-approve}.\r\n   *\r\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    _approve(owner, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {ERC20}.\r\n   *\r\n   * NOTE: Does not update the allowance if the current allowance\r\n   * is the maximum `uint256`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` and `to` cannot be the zero address.\r\n   * - `from` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for ``from``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    address spender = _msgSender();\r\n    _spendAllowance(from, spender, amount);\r\n    _transfer(from, to, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    _approve(owner, spender, _allowances[owner][spender] + addedValue);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    address owner = _msgSender();\r\n    uint256 currentAllowance = _allowances[owner][spender];\r\n    require(\r\n      currentAllowance >= subtractedValue,\r\n      \"ERC20: decreased allowance below zero\"\r\n    );\r\n    unchecked {\r\n      _approve(owner, spender, currentAllowance - subtractedValue);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n   *\r\n   * This internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `from` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(from != address(0), \"ERC20: transfer from the zero address\");\r\n    require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n    _beforeTokenTransfer(from, to, amount);\r\n\r\n    uint256 fromBalance = _balances[from];\r\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n    unchecked {\r\n      _balances[from] = fromBalance - amount;\r\n    }\r\n    _balances[to] += amount;\r\n\r\n    emit Transfer(from, to, amount);\r\n\r\n    _afterTokenTransfer(from, to, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   */\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    _totalSupply += amount;\r\n    _balances[account] += amount;\r\n    emit Transfer(address(0), account, amount);\r\n\r\n    _afterTokenTransfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, reducing the\r\n   * total supply.\r\n   *\r\n   * Emits a {Transfer} event with `to` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   * - `account` must have at least `amount` tokens.\r\n   */\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    uint256 accountBalance = _balances[account];\r\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n    unchecked {\r\n      _balances[account] = accountBalance - amount;\r\n    }\r\n    _totalSupply -= amount;\r\n\r\n    emit Transfer(account, address(0), amount);\r\n\r\n    _afterTokenTransfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n   *\r\n   * This internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Spend `amount` form the allowance of `owner` toward `spender`.\r\n   *\r\n   * Does not update the allowance amount in case of infinite allowance.\r\n   * Revert if not enough allowance is available.\r\n   *\r\n   * Might emit an {Approval} event.\r\n   */\r\n  function _spendAllowance(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    uint256 currentAllowance = allowance(owner, spender);\r\n    if (currentAllowance != type(uint256).max) {\r\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n      unchecked {\r\n        _approve(owner, spender, currentAllowance - amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * will be transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n\r\n  /**\r\n   * @dev Hook that is called after any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * has been transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _afterTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n}\r\n"
    },
    "contracts/interfaces/IWommf.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\n\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\r\n\r\npragma solidity 0.8.16; // latest available for using OZ\r\n\r\ninterface IWOMMF is IERC20 {\r\n  function wrap(uint256 _OMMFAmount) external;\r\n\r\n  function unwrap(uint256 _wOMMFAmount) external;\r\n\r\n  function getwOMMFByOMMF(uint256 _OMMFAmount) external view returns (uint256);\r\n\r\n  function getOMMFbywOMMF(uint256 _wOMMFAmount) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IOmmf.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\n\r\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\r\n\r\npragma solidity 0.8.16; // latest available for using OZ\r\n\r\ninterface IOMMF is IERC20 {\r\n  function getPooledCashByShares(uint256) external view returns (uint256);\r\n\r\n  function getSharesByPooledCash(uint256) external view returns (uint256);\r\n\r\n  function submit(address _referral) external payable returns (uint256);\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n  /**\r\n   * @dev Emitted when the pause is triggered by `account`.\r\n   */\r\n  event Paused(address account);\r\n\r\n  /**\r\n   * @dev Emitted when the pause is lifted by `account`.\r\n   */\r\n  event Unpaused(address account);\r\n\r\n  bool private _paused;\r\n\r\n  /**\r\n   * @dev Initializes the contract in unpaused state.\r\n   */\r\n  constructor() {\r\n    _paused = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the contract is paused, and false otherwise.\r\n   */\r\n  function paused() public view virtual returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must not be paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused(), \"Pausable: paused\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must be paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused(), \"Pausable: not paused\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Triggers stopped state.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must not be paused.\r\n   */\r\n  function _pause() internal virtual whenNotPaused {\r\n    _paused = true;\r\n    emit Paused(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns to normal state.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must be paused.\r\n   */\r\n  function _unpause() internal virtual whenPaused {\r\n    _paused = false;\r\n    emit Unpaused(_msgSender());\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IRWAHubNonStableInstantMint.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IRWAHub.sol\";\r\n\r\ninterface IRWAHubNonStableInstantMint {\r\n  /**\r\n   * @notice Event emitted when an instant mint is completed\r\n   *\r\n   * @param user                      The address of the user\r\n   * @param collateralAmountDeposited The amount of collateral deposited\r\n   * @param collateralAmountAfterFees The amount of collateral after fees\r\n   * @param feesInCollateral          The amount of fees in collateral\r\n   * @param rwaGiven                  The amount of rwa minted to the user\r\n   * @param priceMinted               The price at which the rwa was minted at\r\n   * @param depositId                 The id of the deposit in RWAHub\r\n   */\r\n  event InstantMint(\r\n    address indexed user,\r\n    uint256 collateralAmountDeposited,\r\n    uint256 collateralAmountAfterFees,\r\n    uint256 feesInCollateral,\r\n    uint256 rwaGiven,\r\n    uint256 priceMinted,\r\n    bytes32 depositId\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when the excess of the instant mint is claimed\r\n   *\r\n   * @param user           The address of the user\r\n   * @param totalRWAOwed   The total amount of rwa owed (instant mint + excess)\r\n   * @param rwaExcessDue   The amount of excess rwa owed\r\n   * @param rwaExcessGiven The amount of rwa excess given in this claim\r\n   * @param priceClaimed   The price at which the excess rwa was claimed at\r\n   * @param depositId      The id of the deposit in RWAHub\r\n   */\r\n  event ExcessMintClaimed(\r\n    address indexed user,\r\n    uint256 totalRWAOwed,\r\n    uint256 rwaExcessDue,\r\n    uint256 rwaExcessGiven,\r\n    uint256 priceClaimed,\r\n    bytes32 depositId\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when instant mint given is overriden\r\n   *\r\n   * @param depositId   The id of the deposit in RWAHub\r\n   * @param oldGivenAmt The old amount of rwa given\r\n   * @param newGivenAmt The new amount of rwa given\r\n   */\r\n  event InstantMintGivenOverriden(\r\n    bytes32 indexed depositId,\r\n    uint256 oldGivenAmt,\r\n    uint256 newGivenAmt\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when instant mint asset manager is set\r\n   *\r\n   * @param oldInstantMintAssetManager Old instant mint asset manager\r\n   * @param newInstantMintAssetManager New instant mint asset manager\r\n   */\r\n  event InstantMintAssetManagerSet(\r\n    address oldInstantMintAssetManager,\r\n    address newInstantMintAssetManager\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when instant mint amount % (in bps) is set\r\n   *\r\n   * @param oldInstantMintBps Old instant mint amount in bps\r\n   * @param newInstantMintBps New instant mint amount in bps\r\n   */\r\n  event InstantMintAmountSet(\r\n    uint256 oldInstantMintBps,\r\n    uint256 newInstantMintBps\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when instant mints are paused\r\n   *\r\n   * @param caller Address which initiated the pause\r\n   */\r\n  event InstantMintPaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when instant mints are unpaused\r\n   *\r\n   * @param caller Address which initiated the unpause\r\n   */\r\n  event InstantMintUnpaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when claiming excess is paused\r\n   *\r\n   * @param caller Address which initiated the pause\r\n   */\r\n  event ClaimExcessPaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when claiming excess is unpaused\r\n   *\r\n   * @param caller Address which initiated the unpause\r\n   */\r\n  event ClaimExcessUnpaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when instant mint fee is set\r\n   *\r\n   * @param oldFee Old fee\r\n   * @param newFee New fee\r\n   *\r\n   * @dev See inheriting contract for decimals representation\r\n   */\r\n  event InstantMintFeeSet(uint256 oldFee, uint256 newFee);\r\n\r\n  // Errors\r\n  error CannotClaimExcess();\r\n  error CannotClaimMint();\r\n}\r\n"
    },
    "contracts/usdy/allowlist/AllowlistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/interfaces/IAllowlist.sol\";\r\nimport \"contracts/interfaces/IAllowlistClient.sol\";\r\n\r\n/**\r\n * @title AllowlistClient\r\n * @author Ondo Finance\r\n * @notice This abstract contract manages state required for clients\r\n *         of the allowlist\r\n */\r\nabstract contract AllowlistClient is IAllowlistClient {\r\n  // allowlist address\r\n  IAllowlist public override allowlist;\r\n\r\n  /**\r\n   * @notice Constructor\r\n   *\r\n   * @param _allowlist Address of the blocklist contract\r\n   */\r\n  constructor(address _allowlist) {\r\n    _setAllowlist(_allowlist);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the allowlist address for this client\r\n   *\r\n   * @param _allowlist The new allowlist address\r\n   */\r\n  function _setAllowlist(address _allowlist) internal {\r\n    if (_allowlist == address(0)) {\r\n      revert AllowlistZeroAddress();\r\n    }\r\n    address oldAllowlist = address(allowlist);\r\n    allowlist = IAllowlist(_allowlist);\r\n    emit AllowlistSet(oldAllowlist, _allowlist);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether an address has been Blocked\r\n   *\r\n   * @param account The account to check\r\n   */\r\n  function _isAllowed(address account) internal view returns (bool) {\r\n    return allowlist.isAllowed(account);\r\n  }\r\n}\r\n"
    },
    "contracts/sanctions/SanctionsListClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\r\n\r\n      ▄▄█████████▄\r\n   ╓██▀└ ,╓▄▄▄, '▀██▄\r\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\r\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\r\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\r\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\r\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\r\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\r\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\r\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\r\n      ╙▀▀██████R⌐\r\n\r\n */\r\npragma solidity 0.8.16;\r\n\r\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\r\nimport \"contracts/sanctions/ISanctionsListClient.sol\";\r\n\r\n/**\r\n * @title SanctionsListClient\r\n * @author Ondo Finance\r\n * @notice This abstract contract manages state required for clients\r\n *         of the sanctions list\r\n */\r\nabstract contract SanctionsListClient is ISanctionsListClient {\r\n  // Sanctions list address\r\n  ISanctionsList public override sanctionsList;\r\n\r\n  /**\r\n   * @notice Constructor\r\n   *\r\n   * @param _sanctionsList Address of the sanctions list contract\r\n   */\r\n  constructor(address _sanctionsList) {\r\n    _setSanctionsList(_sanctionsList);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the sanctions list address for this client\r\n   *\r\n   * @param _sanctionsList The new sanctions list address\r\n   */\r\n  function _setSanctionsList(address _sanctionsList) internal {\r\n    if (_sanctionsList == address(0)) {\r\n      revert SanctionsListZeroAddress();\r\n    }\r\n    address oldSanctionsList = address(sanctionsList);\r\n    sanctionsList = ISanctionsList(_sanctionsList);\r\n    emit SanctionsListSet(oldSanctionsList, _sanctionsList);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks whether an address has been sanctioned\r\n   *\r\n   * @param account The account to check\r\n   */\r\n  function _isSanctioned(address account) internal view returns (bool) {\r\n    return sanctionsList.isSanctioned(account);\r\n  }\r\n\r\n  /**\r\n   * @dev This empty reserved space is put in place to allow future versions to add new\r\n   * variables without shifting down storage in the inheritance chain.\r\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n   */\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n  struct Counter {\r\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n    uint256 _value; // default: 0\r\n  }\r\n\r\n  function current(Counter storage counter) internal view returns (uint256) {\r\n    return counter._value;\r\n  }\r\n\r\n  function increment(Counter storage counter) internal {\r\n    unchecked {\r\n      counter._value += 1;\r\n    }\r\n  }\r\n\r\n  function decrement(Counter storage counter) internal {\r\n    uint256 value = counter._value;\r\n    require(value > 0, \"Counter: decrement overflow\");\r\n    unchecked {\r\n      counter._value = value - 1;\r\n    }\r\n  }\r\n\r\n  function reset(Counter storage counter) internal {\r\n    counter._value = 0;\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IRWAHubInstantMints.sol": {
      "content": "pragma solidity 0.8.16;\r\n\r\ninterface IRWAHubInstantMints {\r\n  function instantMint(uint256 amount) external;\r\n\r\n  function instantRedemption(uint256 amount) external;\r\n\r\n  function setInstantMintFee(uint256 _instantMintFee) external;\r\n\r\n  function setInstantRedemptionFee(uint256 _instantRedemptionFee) external;\r\n\r\n  function setInstantMintPriceId(uint256 _instantMintPriceId) external;\r\n\r\n  function setInstantRedemptionPriceId(\r\n    uint256 _instantRedemptionPriceId\r\n  ) external;\r\n\r\n  function pauseInstantMint() external;\r\n\r\n  function unpauseInstantMint() external;\r\n\r\n  function pauseInstantRedemption() external;\r\n\r\n  function unpauseInstantRedemption() external;\r\n\r\n  function setInstantMintLimit(uint256 newMintLimit) external;\r\n\r\n  function setInstantRedemptionLimit(uint256 newRedemptionLimit) external;\r\n\r\n  function setInstantMintLimitDuration(uint256 newMintLimitDuration) external;\r\n\r\n  function setInstantRedemptionLimitDuration(\r\n    uint256 newRedemptionLimitDuration\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Event emitted when instant mint fee is set\r\n   *\r\n   * @param oldFee Old fee\r\n   * @param newFee New fee\r\n   *\r\n   * @dev See inheriting contract for decimals representation\r\n   */\r\n  event InstantMintFeeSet(uint256 oldFee, uint256 newFee);\r\n\r\n  /**\r\n   * @notice Event emitted when instant redeem fee is set\r\n   *\r\n   * @param oldFee Old fee\r\n   * @param newFee New fee\r\n   *\r\n   * @dev See inheriting contract for decimals representation\r\n   */\r\n  event InstantRedemptionFeeSet(uint256 oldFee, uint256 newFee);\r\n\r\n  /**\r\n   * @notice Event emitted when an instant mint is completed\r\n   *\r\n   * @param user                      The address of the user\r\n   * @param collateralAmountDeposited The amount of collateral deposited\r\n   * @param collateralAmountAfterFees The amount of collateral after fees\r\n   * @param feesInCollateral          The amount of fees in collateral\r\n   * @param rwaOwed                   The amount of rwa minted to the user\r\n   * @param price                     The price at which the rwa was minted at\r\n   */\r\n  event InstantMintCompleted(\r\n    address indexed user,\r\n    uint256 collateralAmountDeposited,\r\n    uint256 collateralAmountAfterFees,\r\n    uint256 feesInCollateral,\r\n    uint256 rwaOwed,\r\n    uint256 price\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when an instant redeem is completed\r\n   *\r\n   * @param user                      The address of the user\r\n   * @param rwaAmountBurned           The amount of RWA burned by the user\r\n   * @param collateralAmountAfterFees The amount of collateral after fees returned\r\n   * @param feesInCollateral          The amount of fees in collateral\r\n   * @param price                     The price at which the rwa was redeemed at\r\n   */\r\n  event InstantRedemptionCompleted(\r\n    address indexed user,\r\n    uint256 rwaAmountBurned,\r\n    uint256 collateralAmountAfterFees,\r\n    uint256 feesInCollateral,\r\n    uint256 price\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when instant mints are paused\r\n   *\r\n   * @param caller Address which initiated the pause\r\n   */\r\n  event InstantMintPaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when instant mints are unpaused\r\n   *\r\n   * @param caller Address which initiated the unpause\r\n   */\r\n  event InstantMintUnpaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when instant redeems are paused\r\n   *\r\n   * @param caller Address which initiated the pause\r\n   */\r\n  event InstantRedemptionPaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when instant redeems are unpaused\r\n   *\r\n   * @param caller Address which initiated the unpause\r\n   */\r\n  event InstantRedemptionUnpaused(address caller);\r\n\r\n  /**\r\n   * @notice Event emitted when instant mint priceId is set\r\n   *\r\n   * @param priceId Price Id\r\n   */\r\n  event PriceIdSetForInstantMint(uint256 priceId);\r\n\r\n  /**\r\n   * @notice Event emitted when instant redeem priceId is set\r\n   *\r\n   * @param priceId Price Id\r\n   */\r\n  event PriceIdSetForInstantRedemption(uint256 priceId);\r\n\r\n  /**\r\n   * @notice Event emitted when instant mint asset manager is set\r\n   *\r\n   * @param oldInstantMintAssetManager Old instant mint asset manager\r\n   * @param newInstantMintAssetManager New instant mint asset manager\r\n   */\r\n  event InstantMintAssetManagerSet(\r\n    address oldInstantMintAssetManager,\r\n    address newInstantMintAssetManager\r\n  );\r\n}\r\n"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Compatible with OpenZeppelin Contracts ^5.0.0\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n//check\r\ncontract A$DC is ERC20 {\r\n    constructor()\r\n        ERC20(\"A$DC\", \"A$DC\"){\r\n        _mint(msg.sender, 10000000000000 * 10 ** decimals());\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public {\r\n        amount = amount * 10 ** decimals();\r\n        _mint(to, amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}